/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkfimls"] = self["webpackChunkfimls"] || []).push([["src_components_cinemas_cinemaList_vue"],{

/***/ "./src/components/cinemas/cinemaList.vue":
/*!***********************************************!*\
  !*** ./src/components/cinemas/cinemaList.vue ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _cinemaList_vue_vue_type_template_id_67fb0868_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cinemaList.vue?vue&type=template&id=67fb0868&scoped=true& */ \"./src/components/cinemas/cinemaList.vue?vue&type=template&id=67fb0868&scoped=true&\");\n/* harmony import */ var _cinemaList_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cinemaList.vue?vue&type=script&lang=js& */ \"./src/components/cinemas/cinemaList.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _cinemaList_vue_vue_type_style_index_0_id_67fb0868_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true& */ \"./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true&\");\n/* harmony import */ var _node_modules_vue_vue_loader_v15_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js */ \"./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\");\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,_node_modules_vue_vue_loader_v15_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _cinemaList_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _cinemaList_vue_vue_type_template_id_67fb0868_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,\n  _cinemaList_vue_vue_type_template_id_67fb0868_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  \"67fb0868\",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"src/components/cinemas/cinemaList.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);\n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?");

/***/ }),

/***/ "./src/components/cinemas/cinemaList.vue?vue&type=script&lang=js&":
/*!************************************************************************!*\
  !*** ./src/components/cinemas/cinemaList.vue?vue&type=script&lang=js& ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_40_use_0_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./cinemaList.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=script&lang=js&\");\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_40_use_0_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); \n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?");

/***/ }),

/***/ "./src/components/cinemas/cinemaList.vue?vue&type=template&id=67fb0868&scoped=true&":
/*!******************************************************************************************!*\
  !*** ./src/components/cinemas/cinemaList.vue?vue&type=template&id=67fb0868&scoped=true& ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_40_use_0_node_modules_vue_vue_loader_v15_lib_loaders_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_template_id_67fb0868_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render; },\n/* harmony export */   \"staticRenderFns\": function() { return /* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_40_use_0_node_modules_vue_vue_loader_v15_lib_loaders_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_template_id_67fb0868_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_40_use_0_node_modules_vue_vue_loader_v15_lib_loaders_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_template_id_67fb0868_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!../../../node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./cinemaList.vue?vue&type=template&id=67fb0868&scoped=true& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=template&id=67fb0868&scoped=true&\");\n\n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?");

/***/ }),

/***/ "./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true&":
/*!*********************************************************************************************************!*\
  !*** ./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true& ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_style_loader_index_js_clonedRuleSet_22_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_22_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_22_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_22_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_style_index_0_id_67fb0868_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js??clonedRuleSet-22.use[0]!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true& */ \"./node_modules/vue-style-loader/index.js??clonedRuleSet-22.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true&\");\n/* harmony import */ var _node_modules_vue_style_loader_index_js_clonedRuleSet_22_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_22_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_22_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_22_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_style_index_0_id_67fb0868_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_clonedRuleSet_22_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_22_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_22_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_22_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_style_index_0_id_67fb0868_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_clonedRuleSet_22_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_22_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_22_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_22_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_style_index_0_id_67fb0868_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_vue_style_loader_index_js_clonedRuleSet_22_use_0_node_modules_css_loader_dist_cjs_js_clonedRuleSet_22_use_1_node_modules_vue_vue_loader_v15_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_22_use_2_node_modules_sass_loader_dist_cjs_js_clonedRuleSet_22_use_3_node_modules_vue_vue_loader_v15_lib_index_js_vue_loader_options_cinemaList_vue_vue_type_style_index_0_id_67fb0868_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var better_scroll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! better-scroll */ \"./node_modules/better-scroll/dist/better-scroll.esm.js\");\n/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuex */ \"./node_modules/vuex/dist/vuex.esm.js\");\n// 引入better-scroll模块\n // 引入全局状态和全局方法\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  computed: { // 引入状态\n    ...(0,vuex__WEBPACK_IMPORTED_MODULE_1__.mapState)(['cinemaListState'])\n  },\n  props: {\n    height: {\n      type: String,\n      default: '200px'\n    },\n    list: {\n      type: Array\n    }\n  },\n\n  created() {\n    // 请求猫眼数据\n    // 调用全局函数\n    this.cinemaGet();\n  },\n\n  methods: { // 把全局的异步样式展开\n    ...(0,vuex__WEBPACK_IMPORTED_MODULE_1__.mapActions)(['cinemaGet']),\n\n    initBS() {\n      this.$nextTick(() => {\n        //  一定要在数据回来在初始化\n        new better_scroll__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('.cinema', {\n          scrollbar: {\n            // 这个表示在滑动时候显示进度条 不滑动就不会显示\n            fade: true,\n            // 禁止监听pc 端鼠标移动事件 false 就可以用鼠标了\n            disableMouse: false\n          }\n        });\n      });\n    }\n\n  },\n\n  updated() {\n    // 元素回来后初始化那个滑动的盒子\n    this.initBS();\n  }\n\n});\n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use%5B0%5D!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=template&id=67fb0868&scoped=true&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=template&id=67fb0868&scoped=true& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"staticRenderFns\": function() { return /* binding */ staticRenderFns; }\n/* harmony export */ });\nvar render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\"div\", {\n    staticClass: \"cinema\",\n    style: {\n      height: _vm.height\n    }\n  }, [_c(\"ul\", _vm._l(_vm.list, function (item) {\n    return _c(\"li\", {\n      key: item.cinemaId\n    }, [_c(\"div\", [_c(\"p\", {\n      staticClass: \"cinemaName\"\n    }, [_vm._v(_vm._s(item.name))]), _c(\"p\", [_vm._v(_vm._s(item.address))])]), _c(\"span\", [_vm._v(\" ￥\"), _c(\"i\", [_vm._v(_vm._s((item.lowPrice / 100).toFixed(1)))]), _vm._v(\"起 \")])]);\n  }), 0)]);\n};\n\nvar staticRenderFns = [];\nrender._withStripped = true;\n\n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?./node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use%5B0%5D!./node_modules/@vue/vue-loader-v15/lib/loaders/templateLoader.js??ruleSet%5B1%5D.rules%5B3%5D!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options");

/***/ }),

/***/ "./node_modules/better-scroll/dist/better-scroll.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/better-scroll/dist/better-scroll.esm.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Behavior\": function() { return /* binding */ Behavior; },\n/* harmony export */   \"CustomOptions\": function() { return /* binding */ CustomOptions; },\n/* harmony export */   \"Indicators\": function() { return /* binding */ Indicators; },\n/* harmony export */   \"InfinityScroll\": function() { return /* binding */ InfinityScroll; },\n/* harmony export */   \"MouseWheel\": function() { return /* binding */ MouseWheel; },\n/* harmony export */   \"Movable\": function() { return /* binding */ Movable; },\n/* harmony export */   \"NestedScroll\": function() { return /* binding */ NestedScroll; },\n/* harmony export */   \"ObserveDom\": function() { return /* binding */ ObserveDOM; },\n/* harmony export */   \"ObserveImage\": function() { return /* binding */ ObserveImage; },\n/* harmony export */   \"PullDownRefresh\": function() { return /* binding */ PullDown; },\n/* harmony export */   \"PullUpLoad\": function() { return /* binding */ PullUp; },\n/* harmony export */   \"ScrollBar\": function() { return /* binding */ ScrollBar; },\n/* harmony export */   \"Slide\": function() { return /* binding */ Slide; },\n/* harmony export */   \"Wheel\": function() { return /* binding */ Wheel; },\n/* harmony export */   \"Zoom\": function() { return /* binding */ Zoom; },\n/* harmony export */   \"createBScroll\": function() { return /* binding */ createBScroll; },\n/* harmony export */   \"default\": function() { return /* binding */ BScroll; }\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.error.cause.js */ \"./node_modules/core-js/modules/es.error.cause.js\");\n/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"./node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var core_js_modules_es_array_unshift_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.array.unshift.js */ \"./node_modules/core-js/modules/es.array.unshift.js\");\n/* harmony import */ var core_js_modules_es_array_unshift_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_unshift_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n/*!\n * better-scroll / better-scroll\n * (c) 2016-2022 ustbhuangyi\n * Released under the MIT License.\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n\nvar propertiesConfig$7 = [{\n  sourceKey: 'scroller.scrollBehaviorX.currentPos',\n  key: 'x'\n}, {\n  sourceKey: 'scroller.scrollBehaviorY.currentPos',\n  key: 'y'\n}, {\n  sourceKey: 'scroller.scrollBehaviorX.hasScroll',\n  key: 'hasHorizontalScroll'\n}, {\n  sourceKey: 'scroller.scrollBehaviorY.hasScroll',\n  key: 'hasVerticalScroll'\n}, {\n  sourceKey: 'scroller.scrollBehaviorX.contentSize',\n  key: 'scrollerWidth'\n}, {\n  sourceKey: 'scroller.scrollBehaviorY.contentSize',\n  key: 'scrollerHeight'\n}, {\n  sourceKey: 'scroller.scrollBehaviorX.maxScrollPos',\n  key: 'maxScrollX'\n}, {\n  sourceKey: 'scroller.scrollBehaviorY.maxScrollPos',\n  key: 'maxScrollY'\n}, {\n  sourceKey: 'scroller.scrollBehaviorX.minScrollPos',\n  key: 'minScrollX'\n}, {\n  sourceKey: 'scroller.scrollBehaviorY.minScrollPos',\n  key: 'minScrollY'\n}, {\n  sourceKey: 'scroller.scrollBehaviorX.movingDirection',\n  key: 'movingDirectionX'\n}, {\n  sourceKey: 'scroller.scrollBehaviorY.movingDirection',\n  key: 'movingDirectionY'\n}, {\n  sourceKey: 'scroller.scrollBehaviorX.direction',\n  key: 'directionX'\n}, {\n  sourceKey: 'scroller.scrollBehaviorY.direction',\n  key: 'directionY'\n}, {\n  sourceKey: 'scroller.actions.enabled',\n  key: 'enabled'\n}, {\n  sourceKey: 'scroller.animater.pending',\n  key: 'pending'\n}, {\n  sourceKey: 'scroller.animater.stop',\n  key: 'stop'\n}, {\n  sourceKey: 'scroller.scrollTo',\n  key: 'scrollTo'\n}, {\n  sourceKey: 'scroller.scrollBy',\n  key: 'scrollBy'\n}, {\n  sourceKey: 'scroller.scrollToElement',\n  key: 'scrollToElement'\n}, {\n  sourceKey: 'scroller.resetPosition',\n  key: 'resetPosition'\n}];\n\nfunction warn(msg) {\n  console.error(\"[BScroll warn]: \" + msg);\n}\n\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error('[BScroll] ' + msg);\n  }\n} // ssr support\n\n\nvar inBrowser = typeof window !== 'undefined';\nvar ua = inBrowser && navigator.userAgent.toLowerCase();\nvar isWeChatDevTools = !!(ua && /wechatdevtools/.test(ua));\nvar isAndroid = ua && ua.indexOf('android') > 0;\n/* istanbul ignore next */\n\nvar isIOSBadVersion = function () {\n  if (typeof ua === 'string') {\n    var regex = /os (\\d\\d?_\\d(_\\d)?)/;\n    var matches = regex.exec(ua);\n    if (!matches) return false;\n    var parts = matches[1].split('_').map(function (item) {\n      return parseInt(item, 10);\n    }); // ios version >= 13.4 issue 982\n\n    return !!(parts[0] === 13 && parts[1] >= 4);\n  }\n\n  return false;\n}();\n/* istanbul ignore next */\n\n\nvar supportsPassive = false;\n/* istanbul ignore next */\n\nif (inBrowser) {\n  var EventName = 'test-passive';\n\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function () {\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n\n    window.addEventListener(EventName, function () {}, opts);\n  } catch (e) {}\n}\n\nfunction getNow() {\n  return window.performance && window.performance.now && window.performance.timing ? window.performance.now() + window.performance.timing.navigationStart : +new Date();\n}\n\nvar extend = function (target, source) {\n  for (var key in source) {\n    target[key] = source[key];\n  }\n\n  return target;\n};\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction getDistance(x, y) {\n  return Math.sqrt(x * x + y * y);\n}\n\nfunction between(x, min, max) {\n  if (x < min) {\n    return min;\n  }\n\n  if (x > max) {\n    return max;\n  }\n\n  return x;\n}\n\nfunction findIndex(ary, fn) {\n  if (ary.findIndex) {\n    return ary.findIndex(fn);\n  }\n\n  var index = -1;\n  ary.some(function (item, i, ary) {\n    var ret = fn(item, i, ary);\n\n    if (ret) {\n      index = i;\n      return ret;\n    }\n  });\n  return index;\n}\n\nvar elementStyle = inBrowser && document.createElement('div').style;\n\nvar vendor = function () {\n  /* istanbul ignore if  */\n  if (!inBrowser) {\n    return false;\n  }\n\n  var transformNames = [{\n    key: 'standard',\n    value: 'transform'\n  }, {\n    key: 'webkit',\n    value: 'webkitTransform'\n  }, {\n    key: 'Moz',\n    value: 'MozTransform'\n  }, {\n    key: 'O',\n    value: 'OTransform'\n  }, {\n    key: 'ms',\n    value: 'msTransform'\n  }];\n\n  for (var _i = 0, transformNames_1 = transformNames; _i < transformNames_1.length; _i++) {\n    var obj = transformNames_1[_i];\n\n    if (elementStyle[obj.value] !== undefined) {\n      return obj.key;\n    }\n  }\n  /* istanbul ignore next  */\n\n\n  return false;\n}();\n/* istanbul ignore next  */\n\n\nfunction prefixStyle(style) {\n  if (vendor === false) {\n    return style;\n  }\n\n  if (vendor === 'standard') {\n    if (style === 'transitionEnd') {\n      return 'transitionend';\n    }\n\n    return style;\n  }\n\n  return vendor + style.charAt(0).toUpperCase() + style.substr(1);\n}\n\nfunction getElement(el) {\n  return typeof el === 'string' ? document.querySelector(el) : el;\n}\n\nfunction addEvent(el, type, fn, capture) {\n  var useCapture = supportsPassive ? {\n    passive: false,\n    capture: !!capture\n  } : !!capture;\n  el.addEventListener(type, fn, useCapture);\n}\n\nfunction removeEvent(el, type, fn, capture) {\n  el.removeEventListener(type, fn, {\n    capture: !!capture\n  });\n}\n\nfunction maybePrevent(e) {\n  if (e.cancelable) {\n    e.preventDefault();\n  }\n}\n\nfunction offset(el) {\n  var left = 0;\n  var top = 0;\n\n  while (el) {\n    left -= el.offsetLeft;\n    top -= el.offsetTop;\n    el = el.offsetParent;\n  }\n\n  return {\n    left: left,\n    top: top\n  };\n}\n\nfunction offsetToBody(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: -(rect.left + window.pageXOffset),\n    top: -(rect.top + window.pageYOffset)\n  };\n}\n\nvar cssVendor = vendor && vendor !== 'standard' ? '-' + vendor.toLowerCase() + '-' : '';\nvar transform = prefixStyle('transform');\nvar transition = prefixStyle('transition');\nvar hasPerspective = inBrowser && prefixStyle('perspective') in elementStyle; // fix issue #361\n\nvar hasTouch = inBrowser && ('ontouchstart' in window || isWeChatDevTools);\nvar hasTransition = inBrowser && transition in elementStyle;\nvar style = {\n  transform: transform,\n  transition: transition,\n  transitionTimingFunction: prefixStyle('transitionTimingFunction'),\n  transitionDuration: prefixStyle('transitionDuration'),\n  transitionDelay: prefixStyle('transitionDelay'),\n  transformOrigin: prefixStyle('transformOrigin'),\n  transitionEnd: prefixStyle('transitionEnd'),\n  transitionProperty: prefixStyle('transitionProperty')\n};\nvar eventTypeMap = {\n  touchstart: 1,\n  touchmove: 1,\n  touchend: 1,\n  touchcancel: 1,\n  mousedown: 2,\n  mousemove: 2,\n  mouseup: 2\n};\n\nfunction getRect(el) {\n  /* istanbul ignore if  */\n  if (el instanceof window.SVGElement) {\n    var rect = el.getBoundingClientRect();\n    return {\n      top: rect.top,\n      left: rect.left,\n      width: rect.width,\n      height: rect.height\n    };\n  } else {\n    return {\n      top: el.offsetTop,\n      left: el.offsetLeft,\n      width: el.offsetWidth,\n      height: el.offsetHeight\n    };\n  }\n}\n\nfunction preventDefaultExceptionFn(el, exceptions) {\n  for (var i in exceptions) {\n    if (exceptions[i].test(el[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar tagExceptionFn = preventDefaultExceptionFn;\n\nfunction tap(e, eventName) {\n  var ev = document.createEvent('Event');\n  ev.initEvent(eventName, true, true);\n  ev.pageX = e.pageX;\n  ev.pageY = e.pageY;\n  e.target.dispatchEvent(ev);\n}\n\nfunction click(e, event) {\n  if (event === void 0) {\n    event = 'click';\n  }\n\n  var eventSource;\n\n  if (e.type === 'mouseup') {\n    eventSource = e;\n  } else if (e.type === 'touchend' || e.type === 'touchcancel') {\n    eventSource = e.changedTouches[0];\n  }\n\n  var posSrc = {};\n\n  if (eventSource) {\n    posSrc.screenX = eventSource.screenX || 0;\n    posSrc.screenY = eventSource.screenY || 0;\n    posSrc.clientX = eventSource.clientX || 0;\n    posSrc.clientY = eventSource.clientY || 0;\n  }\n\n  var ev;\n  var bubbles = true;\n  var cancelable = true;\n  var ctrlKey = e.ctrlKey,\n      shiftKey = e.shiftKey,\n      altKey = e.altKey,\n      metaKey = e.metaKey;\n  var pressedKeysMap = {\n    ctrlKey: ctrlKey,\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey\n  };\n\n  if (typeof MouseEvent !== 'undefined') {\n    try {\n      ev = new MouseEvent(event, extend(__assign({\n        bubbles: bubbles,\n        cancelable: cancelable\n      }, pressedKeysMap), posSrc));\n    } catch (e) {\n      /* istanbul ignore next */\n      createEvent();\n    }\n  } else {\n    createEvent();\n  }\n\n  function createEvent() {\n    ev = document.createEvent('Event');\n    ev.initEvent(event, bubbles, cancelable);\n    extend(ev, posSrc);\n  } // forwardedTouchEvent set to true in case of the conflict with fastclick\n\n\n  ev.forwardedTouchEvent = true;\n  ev._constructed = true;\n  e.target.dispatchEvent(ev);\n}\n\nfunction dblclick(e) {\n  click(e, 'dblclick');\n}\n\nfunction prepend(el, target) {\n  var firstChild = target.firstChild;\n\n  if (firstChild) {\n    before(el, firstChild);\n  } else {\n    target.appendChild(el);\n  }\n}\n\nfunction before(el, target) {\n  var parentNode = target.parentNode;\n  parentNode.insertBefore(el, target);\n}\n\nfunction removeChild(el, child) {\n  el.removeChild(child);\n}\n\nfunction hasClass(el, className) {\n  var reg = new RegExp('(^|\\\\s)' + className + '(\\\\s|$)');\n  return reg.test(el.className);\n}\n\nfunction HTMLCollectionToArray(el) {\n  return Array.prototype.slice.call(el, 0);\n}\n\nfunction getClientSize(el) {\n  return {\n    width: el.clientWidth,\n    height: el.clientHeight\n  };\n}\n\nvar ease = {\n  // easeOutQuint\n  swipe: {\n    style: 'cubic-bezier(0.23, 1, 0.32, 1)',\n    fn: function (t) {\n      return 1 + --t * t * t * t * t;\n    }\n  },\n  // easeOutQuard\n  swipeBounce: {\n    style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',\n    fn: function (t) {\n      return t * (2 - t);\n    }\n  },\n  // easeOutQuart\n  bounce: {\n    style: 'cubic-bezier(0.165, 0.84, 0.44, 1)',\n    fn: function (t) {\n      return 1 - --t * t * t * t;\n    }\n  }\n};\nvar DEFAULT_INTERVAL = 1000 / 60;\nvar windowCompat = inBrowser && window;\n/* istanbul ignore next */\n\nfunction noop$1() {}\n\nvar requestAnimationFrame = function () {\n  /* istanbul ignore if  */\n  if (!inBrowser) {\n    return noop$1;\n  }\n\n  return windowCompat.requestAnimationFrame || windowCompat.webkitRequestAnimationFrame || windowCompat.mozRequestAnimationFrame || windowCompat.oRequestAnimationFrame || // if all else fails, use setTimeout\n  function (callback) {\n    return window.setTimeout(callback, callback.interval || DEFAULT_INTERVAL); // make interval as precise as possible.\n  };\n}();\n\nvar cancelAnimationFrame = function () {\n  /* istanbul ignore if  */\n  if (!inBrowser) {\n    return noop$1;\n  }\n\n  return windowCompat.cancelAnimationFrame || windowCompat.webkitCancelAnimationFrame || windowCompat.mozCancelAnimationFrame || windowCompat.oCancelAnimationFrame || function (id) {\n    window.clearTimeout(id);\n  };\n}();\n/* istanbul ignore next */\n\n\nvar noop = function (val) {};\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nvar getProperty = function (obj, key) {\n  var keys = key.split('.');\n\n  for (var i = 0; i < keys.length - 1; i++) {\n    obj = obj[keys[i]];\n    if (typeof obj !== 'object' || !obj) return;\n  }\n\n  var lastKey = keys.pop();\n\n  if (typeof obj[lastKey] === 'function') {\n    return function () {\n      return obj[lastKey].apply(obj, arguments);\n    };\n  } else {\n    return obj[lastKey];\n  }\n};\n\nvar setProperty = function (obj, key, value) {\n  var keys = key.split('.');\n  var temp;\n\n  for (var i = 0; i < keys.length - 1; i++) {\n    temp = keys[i];\n    if (!obj[temp]) obj[temp] = {};\n    obj = obj[temp];\n  }\n\n  obj[keys.pop()] = value;\n};\n\nfunction propertiesProxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return getProperty(this, sourceKey);\n  };\n\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    setProperty(this, sourceKey, val);\n  };\n\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nvar EventEmitter =\n/** @class */\nfunction () {\n  function EventEmitter(names) {\n    this.events = {};\n    this.eventTypes = {};\n    this.registerType(names);\n  }\n\n  EventEmitter.prototype.on = function (type, fn, context) {\n    if (context === void 0) {\n      context = this;\n    }\n\n    this.hasType(type);\n\n    if (!this.events[type]) {\n      this.events[type] = [];\n    }\n\n    this.events[type].push([fn, context]);\n    return this;\n  };\n\n  EventEmitter.prototype.once = function (type, fn, context) {\n    var _this = this;\n\n    if (context === void 0) {\n      context = this;\n    }\n\n    this.hasType(type);\n\n    var magic = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      _this.off(type, magic);\n\n      var ret = fn.apply(context, args);\n\n      if (ret === true) {\n        return ret;\n      }\n    };\n\n    magic.fn = fn;\n    this.on(type, magic);\n    return this;\n  };\n\n  EventEmitter.prototype.off = function (type, fn) {\n    if (!type && !fn) {\n      this.events = {};\n      return this;\n    }\n\n    if (type) {\n      this.hasType(type);\n\n      if (!fn) {\n        this.events[type] = [];\n        return this;\n      }\n\n      var events = this.events[type];\n\n      if (!events) {\n        return this;\n      }\n\n      var count = events.length;\n\n      while (count--) {\n        if (events[count][0] === fn || events[count][0] && events[count][0].fn === fn) {\n          events.splice(count, 1);\n        }\n      }\n\n      return this;\n    }\n  };\n\n  EventEmitter.prototype.trigger = function (type) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    this.hasType(type);\n    var events = this.events[type];\n\n    if (!events) {\n      return;\n    }\n\n    var len = events.length;\n\n    var eventsCopy = __spreadArrays(events);\n\n    var ret;\n\n    for (var i = 0; i < len; i++) {\n      var event_1 = eventsCopy[i];\n      var fn = event_1[0],\n          context = event_1[1];\n\n      if (fn) {\n        ret = fn.apply(context, args);\n\n        if (ret === true) {\n          return ret;\n        }\n      }\n    }\n  };\n\n  EventEmitter.prototype.registerType = function (names) {\n    var _this = this;\n\n    names.forEach(function (type) {\n      _this.eventTypes[type] = type;\n    });\n  };\n\n  EventEmitter.prototype.destroy = function () {\n    this.events = {};\n    this.eventTypes = {};\n  };\n\n  EventEmitter.prototype.hasType = function (type) {\n    var types = this.eventTypes;\n    var isType = types[type] === type;\n\n    if (!isType) {\n      warn(\"EventEmitter has used unknown event type: \\\"\" + type + \"\\\", should be oneof [\" + (\"\" + Object.keys(types).map(function (_) {\n        return JSON.stringify(_);\n      })) + \"]\");\n    }\n  };\n\n  return EventEmitter;\n}();\n\nvar EventRegister =\n/** @class */\nfunction () {\n  function EventRegister(wrapper, events) {\n    this.wrapper = wrapper;\n    this.events = events;\n    this.addDOMEvents();\n  }\n\n  EventRegister.prototype.destroy = function () {\n    this.removeDOMEvents();\n    this.events = [];\n  };\n\n  EventRegister.prototype.addDOMEvents = function () {\n    this.handleDOMEvents(addEvent);\n  };\n\n  EventRegister.prototype.removeDOMEvents = function () {\n    this.handleDOMEvents(removeEvent);\n  };\n\n  EventRegister.prototype.handleDOMEvents = function (eventOperation) {\n    var _this = this;\n\n    var wrapper = this.wrapper;\n    this.events.forEach(function (event) {\n      eventOperation(wrapper, event.name, _this, !!event.capture);\n    });\n  };\n\n  EventRegister.prototype.handleEvent = function (e) {\n    var eventType = e.type;\n    this.events.some(function (event) {\n      if (event.name === eventType) {\n        event.handler(e);\n        return true;\n      }\n\n      return false;\n    });\n  };\n\n  return EventRegister;\n}();\n\nvar CustomOptions =\n/** @class */\nfunction () {\n  function CustomOptions() {}\n\n  return CustomOptions;\n}();\n\nvar OptionsConstructor =\n/** @class */\nfunction (_super) {\n  __extends(OptionsConstructor, _super);\n\n  function OptionsConstructor() {\n    var _this = _super.call(this) || this;\n\n    _this.startX = 0;\n    _this.startY = 0;\n    _this.scrollX = false;\n    _this.scrollY = true;\n    _this.freeScroll = false;\n    _this.directionLockThreshold = 0;\n    _this.eventPassthrough = \"\"\n    /* None */\n    ;\n    _this.click = false;\n    _this.dblclick = false;\n    _this.tap = '';\n    _this.bounce = {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true\n    };\n    _this.bounceTime = 800;\n    _this.momentum = true;\n    _this.momentumLimitTime = 300;\n    _this.momentumLimitDistance = 15;\n    _this.swipeTime = 2500;\n    _this.swipeBounceTime = 500;\n    _this.deceleration = 0.0015;\n    _this.flickLimitTime = 200;\n    _this.flickLimitDistance = 100;\n    _this.resizePolling = 60;\n    _this.probeType = 0\n    /* Default */\n    ;\n    _this.stopPropagation = false;\n    _this.preventDefault = true;\n    _this.preventDefaultException = {\n      tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|AUDIO)$/\n    };\n    _this.tagException = {\n      tagName: /^TEXTAREA$/\n    };\n    _this.HWCompositing = true;\n    _this.useTransition = true;\n    _this.bindToWrapper = false;\n    _this.bindToTarget = false;\n    _this.disableMouse = hasTouch;\n    _this.disableTouch = !hasTouch;\n    _this.autoBlur = true;\n    _this.autoEndDistance = 5;\n    _this.outOfBoundaryDampingFactor = 1 / 3;\n    _this.specifiedIndexAsContent = 0;\n    _this.quadrant = 1\n    /* First */\n    ;\n    return _this;\n  }\n\n  OptionsConstructor.prototype.merge = function (options) {\n    if (!options) return this;\n\n    for (var key in options) {\n      if (key === 'bounce') {\n        this.bounce = this.resolveBounce(options[key]);\n        continue;\n      }\n\n      this[key] = options[key];\n    }\n\n    return this;\n  };\n\n  OptionsConstructor.prototype.process = function () {\n    this.translateZ = this.HWCompositing && hasPerspective ? ' translateZ(1px)' : '';\n    this.useTransition = this.useTransition && hasTransition;\n    this.preventDefault = !this.eventPassthrough && this.preventDefault; // If you want eventPassthrough I have to lock one of the axes\n\n    this.scrollX = this.eventPassthrough === \"horizontal\"\n    /* Horizontal */\n    ? false : this.scrollX;\n    this.scrollY = this.eventPassthrough === \"vertical\"\n    /* Vertical */\n    ? false : this.scrollY; // With eventPassthrough we also need lockDirection mechanism\n\n    this.freeScroll = this.freeScroll && !this.eventPassthrough; // force true when freeScroll is true\n\n    this.scrollX = this.freeScroll ? true : this.scrollX;\n    this.scrollY = this.freeScroll ? true : this.scrollY;\n    this.directionLockThreshold = this.eventPassthrough ? 0 : this.directionLockThreshold;\n    return this;\n  };\n\n  OptionsConstructor.prototype.resolveBounce = function (bounceOptions) {\n    var DEFAULT_BOUNCE = {\n      top: true,\n      right: true,\n      bottom: true,\n      left: true\n    };\n    var NEGATED_BOUNCE = {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false\n    };\n    var ret;\n\n    if (typeof bounceOptions === 'object') {\n      ret = extend(DEFAULT_BOUNCE, bounceOptions);\n    } else {\n      ret = bounceOptions ? DEFAULT_BOUNCE : NEGATED_BOUNCE;\n    }\n\n    return ret;\n  };\n\n  return OptionsConstructor;\n}(CustomOptions);\n\nvar ActionsHandler =\n/** @class */\nfunction () {\n  function ActionsHandler(wrapper, options) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.hooks = new EventEmitter(['beforeStart', 'start', 'move', 'end', 'click']);\n    this.handleDOMEvents();\n  }\n\n  ActionsHandler.prototype.handleDOMEvents = function () {\n    var _a = this.options,\n        bindToWrapper = _a.bindToWrapper,\n        disableMouse = _a.disableMouse,\n        disableTouch = _a.disableTouch,\n        click = _a.click;\n    var wrapper = this.wrapper;\n    var target = bindToWrapper ? wrapper : window;\n    var wrapperEvents = [];\n    var targetEvents = [];\n    var shouldRegisterTouch = !disableTouch;\n    var shouldRegisterMouse = !disableMouse;\n\n    if (click) {\n      wrapperEvents.push({\n        name: 'click',\n        handler: this.click.bind(this),\n        capture: true\n      });\n    }\n\n    if (shouldRegisterTouch) {\n      wrapperEvents.push({\n        name: 'touchstart',\n        handler: this.start.bind(this)\n      });\n      targetEvents.push({\n        name: 'touchmove',\n        handler: this.move.bind(this)\n      }, {\n        name: 'touchend',\n        handler: this.end.bind(this)\n      }, {\n        name: 'touchcancel',\n        handler: this.end.bind(this)\n      });\n    }\n\n    if (shouldRegisterMouse) {\n      wrapperEvents.push({\n        name: 'mousedown',\n        handler: this.start.bind(this)\n      });\n      targetEvents.push({\n        name: 'mousemove',\n        handler: this.move.bind(this)\n      }, {\n        name: 'mouseup',\n        handler: this.end.bind(this)\n      });\n    }\n\n    this.wrapperEventRegister = new EventRegister(wrapper, wrapperEvents);\n    this.targetEventRegister = new EventRegister(target, targetEvents);\n  };\n\n  ActionsHandler.prototype.beforeHandler = function (e, type) {\n    var _a = this.options,\n        preventDefault = _a.preventDefault,\n        stopPropagation = _a.stopPropagation,\n        preventDefaultException = _a.preventDefaultException;\n    var preventDefaultConditions = {\n      start: function () {\n        return preventDefault && !preventDefaultExceptionFn(e.target, preventDefaultException);\n      },\n      end: function () {\n        return preventDefault && !preventDefaultExceptionFn(e.target, preventDefaultException);\n      },\n      move: function () {\n        return preventDefault;\n      }\n    };\n\n    if (preventDefaultConditions[type]()) {\n      e.preventDefault();\n    }\n\n    if (stopPropagation) {\n      e.stopPropagation();\n    }\n  };\n\n  ActionsHandler.prototype.setInitiated = function (type) {\n    if (type === void 0) {\n      type = 0;\n    }\n\n    this.initiated = type;\n  };\n\n  ActionsHandler.prototype.start = function (e) {\n    var _eventType = eventTypeMap[e.type];\n\n    if (this.initiated && this.initiated !== _eventType) {\n      return;\n    }\n\n    this.setInitiated(_eventType); // if textarea or other html tags in options.tagException is manipulated\n    // do not make bs scroll\n\n    if (tagExceptionFn(e.target, this.options.tagException)) {\n      this.setInitiated();\n      return;\n    } // only allow mouse left button\n\n\n    if (_eventType === 2\n    /* Mouse */\n    && e.button !== 0\n    /* Left */\n    ) return;\n\n    if (this.hooks.trigger(this.hooks.eventTypes.beforeStart, e)) {\n      return;\n    }\n\n    this.beforeHandler(e, 'start');\n    var point = e.touches ? e.touches[0] : e;\n    this.pointX = point.pageX;\n    this.pointY = point.pageY;\n    this.hooks.trigger(this.hooks.eventTypes.start, e);\n  };\n\n  ActionsHandler.prototype.move = function (e) {\n    if (eventTypeMap[e.type] !== this.initiated) {\n      return;\n    }\n\n    this.beforeHandler(e, 'move');\n    var point = e.touches ? e.touches[0] : e;\n    var deltaX = point.pageX - this.pointX;\n    var deltaY = point.pageY - this.pointY;\n    this.pointX = point.pageX;\n    this.pointY = point.pageY;\n\n    if (this.hooks.trigger(this.hooks.eventTypes.move, {\n      deltaX: deltaX,\n      deltaY: deltaY,\n      e: e\n    })) {\n      return;\n    } // auto end when out of viewport\n\n\n    var scrollLeft = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft;\n    var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;\n    var pX = this.pointX - scrollLeft;\n    var pY = this.pointY - scrollTop;\n    var autoEndDistance = this.options.autoEndDistance;\n\n    if (pX > document.documentElement.clientWidth - autoEndDistance || pY > document.documentElement.clientHeight - autoEndDistance || pX < autoEndDistance || pY < autoEndDistance) {\n      this.end(e);\n    }\n  };\n\n  ActionsHandler.prototype.end = function (e) {\n    if (eventTypeMap[e.type] !== this.initiated) {\n      return;\n    }\n\n    this.setInitiated();\n    this.beforeHandler(e, 'end');\n    this.hooks.trigger(this.hooks.eventTypes.end, e);\n  };\n\n  ActionsHandler.prototype.click = function (e) {\n    this.hooks.trigger(this.hooks.eventTypes.click, e);\n  };\n\n  ActionsHandler.prototype.setContent = function (content) {\n    if (content !== this.wrapper) {\n      this.wrapper = content;\n      this.rebindDOMEvents();\n    }\n  };\n\n  ActionsHandler.prototype.rebindDOMEvents = function () {\n    this.wrapperEventRegister.destroy();\n    this.targetEventRegister.destroy();\n    this.handleDOMEvents();\n  };\n\n  ActionsHandler.prototype.destroy = function () {\n    this.wrapperEventRegister.destroy();\n    this.targetEventRegister.destroy();\n    this.hooks.destroy();\n  };\n\n  return ActionsHandler;\n}();\n\nvar translaterMetaData = {\n  x: ['translateX', 'px'],\n  y: ['translateY', 'px']\n};\n\nvar Translater =\n/** @class */\nfunction () {\n  function Translater(content) {\n    this.setContent(content);\n    this.hooks = new EventEmitter(['beforeTranslate', 'translate']);\n  }\n\n  Translater.prototype.getComputedPosition = function () {\n    var cssStyle = window.getComputedStyle(this.content, null);\n    var matrix = cssStyle[style.transform].split(')')[0].split(', ');\n    var x = +(matrix[12] || matrix[4]) || 0;\n    var y = +(matrix[13] || matrix[5]) || 0;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  Translater.prototype.translate = function (point) {\n    var transformStyle = [];\n    Object.keys(point).forEach(function (key) {\n      if (!translaterMetaData[key]) {\n        return;\n      }\n\n      var transformFnName = translaterMetaData[key][0];\n\n      if (transformFnName) {\n        var transformFnArgUnit = translaterMetaData[key][1];\n        var transformFnArg = point[key];\n        transformStyle.push(transformFnName + \"(\" + transformFnArg + transformFnArgUnit + \")\");\n      }\n    });\n    this.hooks.trigger(this.hooks.eventTypes.beforeTranslate, transformStyle, point);\n    this.style[style.transform] = transformStyle.join(' ');\n    this.hooks.trigger(this.hooks.eventTypes.translate, point);\n  };\n\n  Translater.prototype.setContent = function (content) {\n    if (this.content !== content) {\n      this.content = content;\n      this.style = content.style;\n    }\n  };\n\n  Translater.prototype.destroy = function () {\n    this.hooks.destroy();\n  };\n\n  return Translater;\n}();\n\nvar Base =\n/** @class */\nfunction () {\n  function Base(content, translater, options) {\n    this.translater = translater;\n    this.options = options;\n    this.timer = 0;\n    this.hooks = new EventEmitter(['move', 'end', 'beforeForceStop', 'forceStop', 'callStop', 'time', 'timeFunction']);\n    this.setContent(content);\n  }\n\n  Base.prototype.translate = function (endPoint) {\n    this.translater.translate(endPoint);\n  };\n\n  Base.prototype.setPending = function (pending) {\n    this.pending = pending;\n  };\n\n  Base.prototype.setForceStopped = function (forceStopped) {\n    this.forceStopped = forceStopped;\n  };\n\n  Base.prototype.setCallStop = function (called) {\n    this.callStopWhenPending = called;\n  };\n\n  Base.prototype.setContent = function (content) {\n    if (this.content !== content) {\n      this.content = content;\n      this.style = content.style;\n      this.stop();\n    }\n  };\n\n  Base.prototype.clearTimer = function () {\n    if (this.timer) {\n      cancelAnimationFrame(this.timer);\n      this.timer = 0;\n    }\n  };\n\n  Base.prototype.destroy = function () {\n    this.hooks.destroy();\n    cancelAnimationFrame(this.timer);\n  };\n\n  return Base;\n}(); // iOS 13.6 - 14.x, window.getComputedStyle sometimes will get wrong transform value\n// when bs use transition mode\n// eg: translateY -100px -> -200px, when the last frame which is about to scroll to -200px\n// window.getComputedStyle(this.content) will calculate transformY to be -100px(startPoint)\n// it is weird\n// so we should validate position caculated by 'window.getComputedStyle'\n\n\nvar isValidPostion = function (startPoint, endPoint, currentPos, prePos) {\n  var computeDirection = function (endValue, startValue) {\n    var delta = endValue - startValue;\n    var direction = delta > 0 ? -1\n    /* Negative */\n    : delta < 0 ? 1\n    /* Positive */\n    : 0\n    /* Default */\n    ;\n    return direction;\n  };\n\n  var directionX = computeDirection(endPoint.x, startPoint.x);\n  var directionY = computeDirection(endPoint.y, startPoint.y);\n  var deltaX = currentPos.x - prePos.x;\n  var deltaY = currentPos.y - prePos.y;\n  return directionX * deltaX <= 0 && directionY * deltaY <= 0;\n};\n\nvar Transition =\n/** @class */\nfunction (_super) {\n  __extends(Transition, _super);\n\n  function Transition() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Transition.prototype.startProbe = function (startPoint, endPoint) {\n    var _this = this;\n\n    var prePos = startPoint;\n\n    var probe = function () {\n      var pos = _this.translater.getComputedPosition();\n\n      if (isValidPostion(startPoint, endPoint, pos, prePos)) {\n        _this.hooks.trigger(_this.hooks.eventTypes.move, pos);\n      } // call bs.stop() should not dispatch end hook again.\n      // forceStop hook will do this.\n\n      /* istanbul ignore if  */\n\n\n      if (!_this.pending) {\n        if (_this.callStopWhenPending) {\n          _this.callStopWhenPending = false;\n        } else {\n          // transition ends should dispatch end hook.\n          _this.hooks.trigger(_this.hooks.eventTypes.end, pos);\n        }\n      }\n\n      prePos = pos;\n\n      if (_this.pending) {\n        _this.timer = requestAnimationFrame(probe);\n      }\n    }; // when manually call bs.stop(), then bs.scrollTo()\n    // we should reset callStopWhenPending to dispatch end hook\n\n\n    if (this.callStopWhenPending) {\n      this.setCallStop(false);\n    }\n\n    cancelAnimationFrame(this.timer);\n    probe();\n  };\n\n  Transition.prototype.transitionTime = function (time) {\n    if (time === void 0) {\n      time = 0;\n    }\n\n    this.style[style.transitionDuration] = time + 'ms';\n    this.hooks.trigger(this.hooks.eventTypes.time, time);\n  };\n\n  Transition.prototype.transitionTimingFunction = function (easing) {\n    this.style[style.transitionTimingFunction] = easing;\n    this.hooks.trigger(this.hooks.eventTypes.timeFunction, easing);\n  };\n\n  Transition.prototype.transitionProperty = function () {\n    this.style[style.transitionProperty] = style.transform;\n  };\n\n  Transition.prototype.move = function (startPoint, endPoint, time, easingFn) {\n    this.setPending(time > 0);\n    this.transitionTimingFunction(easingFn);\n    this.transitionProperty();\n    this.transitionTime(time);\n    this.translate(endPoint);\n    var isRealtimeProbeType = this.options.probeType === 3\n    /* Realtime */\n    ;\n\n    if (time && isRealtimeProbeType) {\n      this.startProbe(startPoint, endPoint);\n    } // if we change content's transformY in a tick\n    // such as: 0 -> 50px -> 0\n    // transitionend will not be triggered\n    // so we forceupdate by reflow\n\n\n    if (!time) {\n      this._reflow = this.content.offsetHeight;\n\n      if (isRealtimeProbeType) {\n        this.hooks.trigger(this.hooks.eventTypes.move, endPoint);\n      }\n\n      this.hooks.trigger(this.hooks.eventTypes.end, endPoint);\n    }\n  };\n\n  Transition.prototype.doStop = function () {\n    var pending = this.pending;\n    this.setForceStopped(false);\n    this.setCallStop(false); // still in transition\n\n    if (pending) {\n      this.setPending(false);\n      cancelAnimationFrame(this.timer);\n\n      var _a = this.translater.getComputedPosition(),\n          x = _a.x,\n          y = _a.y;\n\n      this.transitionTime();\n      this.translate({\n        x: x,\n        y: y\n      });\n      this.setForceStopped(true);\n      this.setCallStop(true);\n      this.hooks.trigger(this.hooks.eventTypes.forceStop, {\n        x: x,\n        y: y\n      });\n    }\n\n    return pending;\n  };\n\n  Transition.prototype.stop = function () {\n    var stopFromTransition = this.doStop();\n\n    if (stopFromTransition) {\n      this.hooks.trigger(this.hooks.eventTypes.callStop);\n    }\n  };\n\n  return Transition;\n}(Base);\n\nvar Animation =\n/** @class */\nfunction (_super) {\n  __extends(Animation, _super);\n\n  function Animation() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Animation.prototype.move = function (startPoint, endPoint, time, easingFn) {\n    // time is 0\n    if (!time) {\n      this.translate(endPoint);\n\n      if (this.options.probeType === 3\n      /* Realtime */\n      ) {\n        this.hooks.trigger(this.hooks.eventTypes.move, endPoint);\n      }\n\n      this.hooks.trigger(this.hooks.eventTypes.end, endPoint);\n      return;\n    }\n\n    this.animate(startPoint, endPoint, time, easingFn);\n  };\n\n  Animation.prototype.animate = function (startPoint, endPoint, duration, easingFn) {\n    var _this = this;\n\n    var startTime = getNow();\n    var destTime = startTime + duration;\n    var isRealtimeProbeType = this.options.probeType === 3\n    /* Realtime */\n    ;\n\n    var step = function () {\n      var now = getNow(); // js animation end\n\n      if (now >= destTime) {\n        _this.translate(endPoint);\n\n        if (isRealtimeProbeType) {\n          _this.hooks.trigger(_this.hooks.eventTypes.move, endPoint);\n        }\n\n        _this.hooks.trigger(_this.hooks.eventTypes.end, endPoint);\n\n        return;\n      }\n\n      now = (now - startTime) / duration;\n      var easing = easingFn(now);\n      var newPoint = {};\n      Object.keys(endPoint).forEach(function (key) {\n        var startValue = startPoint[key];\n        var endValue = endPoint[key];\n        newPoint[key] = (endValue - startValue) * easing + startValue;\n      });\n\n      _this.translate(newPoint);\n\n      if (isRealtimeProbeType) {\n        _this.hooks.trigger(_this.hooks.eventTypes.move, newPoint);\n      }\n\n      if (_this.pending) {\n        _this.timer = requestAnimationFrame(step);\n      } // call bs.stop() should not dispatch end hook again.\n      // forceStop hook will do this.\n\n      /* istanbul ignore if  */\n\n\n      if (!_this.pending) {\n        if (_this.callStopWhenPending) {\n          _this.callStopWhenPending = false;\n        } else {\n          // raf ends should dispatch end hook.\n          _this.hooks.trigger(_this.hooks.eventTypes.end, endPoint);\n        }\n      }\n    };\n\n    this.setPending(true); // when manually call bs.stop(), then bs.scrollTo()\n    // we should reset callStopWhenPending to dispatch end hook\n\n    if (this.callStopWhenPending) {\n      this.setCallStop(false);\n    }\n\n    cancelAnimationFrame(this.timer);\n    step();\n  };\n\n  Animation.prototype.doStop = function () {\n    var pending = this.pending;\n    this.setForceStopped(false);\n    this.setCallStop(false); // still in requestFrameAnimation\n\n    if (pending) {\n      this.setPending(false);\n      cancelAnimationFrame(this.timer);\n      var pos = this.translater.getComputedPosition();\n      this.setForceStopped(true);\n      this.setCallStop(true);\n      this.hooks.trigger(this.hooks.eventTypes.forceStop, pos);\n    }\n\n    return pending;\n  };\n\n  Animation.prototype.stop = function () {\n    var stopFromAnimation = this.doStop();\n\n    if (stopFromAnimation) {\n      this.hooks.trigger(this.hooks.eventTypes.callStop);\n    }\n  };\n\n  return Animation;\n}(Base);\n\nfunction createAnimater(element, translater, options) {\n  var useTransition = options.useTransition;\n  var animaterOptions = {};\n  Object.defineProperty(animaterOptions, 'probeType', {\n    enumerable: true,\n    configurable: false,\n    get: function () {\n      return options.probeType;\n    }\n  });\n\n  if (useTransition) {\n    return new Transition(element, translater, animaterOptions);\n  } else {\n    return new Animation(element, translater, animaterOptions);\n  }\n}\n\nvar Behavior =\n/** @class */\nfunction () {\n  function Behavior(wrapper, content, options) {\n    this.wrapper = wrapper;\n    this.options = options;\n    this.hooks = new EventEmitter(['beforeComputeBoundary', 'computeBoundary', 'momentum', 'end', 'ignoreHasScroll']);\n    this.refresh(content);\n  }\n\n  Behavior.prototype.start = function () {\n    this.dist = 0;\n    this.setMovingDirection(0\n    /* Default */\n    );\n    this.setDirection(0\n    /* Default */\n    );\n  };\n\n  Behavior.prototype.move = function (delta) {\n    delta = this.hasScroll ? delta : 0;\n    this.setMovingDirection(delta);\n    return this.performDampingAlgorithm(delta, this.options.outOfBoundaryDampingFactor);\n  };\n\n  Behavior.prototype.setMovingDirection = function (delta) {\n    this.movingDirection = delta > 0 ? -1\n    /* Negative */\n    : delta < 0 ? 1\n    /* Positive */\n    : 0\n    /* Default */\n    ;\n  };\n\n  Behavior.prototype.setDirection = function (delta) {\n    this.direction = delta > 0 ? -1\n    /* Negative */\n    : delta < 0 ? 1\n    /* Positive */\n    : 0\n    /* Default */\n    ;\n  };\n\n  Behavior.prototype.performDampingAlgorithm = function (delta, dampingFactor) {\n    var newPos = this.currentPos + delta; // Slow down or stop if outside of the boundaries\n\n    if (newPos > this.minScrollPos || newPos < this.maxScrollPos) {\n      if (newPos > this.minScrollPos && this.options.bounces[0] || newPos < this.maxScrollPos && this.options.bounces[1]) {\n        newPos = this.currentPos + delta * dampingFactor;\n      } else {\n        newPos = newPos > this.minScrollPos ? this.minScrollPos : this.maxScrollPos;\n      }\n    }\n\n    return newPos;\n  };\n\n  Behavior.prototype.end = function (duration) {\n    var momentumInfo = {\n      duration: 0\n    };\n    var absDist = Math.abs(this.currentPos - this.startPos); // start momentum animation if needed\n\n    if (this.options.momentum && duration < this.options.momentumLimitTime && absDist > this.options.momentumLimitDistance) {\n      var wrapperSize = this.direction === -1\n      /* Negative */\n      && this.options.bounces[0] || this.direction === 1\n      /* Positive */\n      && this.options.bounces[1] ? this.wrapperSize : 0;\n      momentumInfo = this.hasScroll ? this.momentum(this.currentPos, this.startPos, duration, this.maxScrollPos, this.minScrollPos, wrapperSize, this.options) : {\n        destination: this.currentPos,\n        duration: 0\n      };\n    } else {\n      this.hooks.trigger(this.hooks.eventTypes.end, momentumInfo);\n    }\n\n    return momentumInfo;\n  };\n\n  Behavior.prototype.momentum = function (current, start, time, lowerMargin, upperMargin, wrapperSize, options) {\n    if (options === void 0) {\n      options = this.options;\n    }\n\n    var distance = current - start;\n    var speed = Math.abs(distance) / time;\n    var deceleration = options.deceleration,\n        swipeBounceTime = options.swipeBounceTime,\n        swipeTime = options.swipeTime;\n    var duration = Math.min(swipeTime, speed * 2 / deceleration);\n    var momentumData = {\n      destination: current + speed * speed / deceleration * (distance < 0 ? -1 : 1),\n      duration: duration,\n      rate: 15\n    };\n    this.hooks.trigger(this.hooks.eventTypes.momentum, momentumData, distance);\n\n    if (momentumData.destination < lowerMargin) {\n      momentumData.destination = wrapperSize ? Math.max(lowerMargin - wrapperSize / 4, lowerMargin - wrapperSize / momentumData.rate * speed) : lowerMargin;\n      momentumData.duration = swipeBounceTime;\n    } else if (momentumData.destination > upperMargin) {\n      momentumData.destination = wrapperSize ? Math.min(upperMargin + wrapperSize / 4, upperMargin + wrapperSize / momentumData.rate * speed) : upperMargin;\n      momentumData.duration = swipeBounceTime;\n    }\n\n    momentumData.destination = Math.round(momentumData.destination);\n    return momentumData;\n  };\n\n  Behavior.prototype.updateDirection = function () {\n    var absDist = this.currentPos - this.absStartPos;\n    this.setDirection(absDist);\n  };\n\n  Behavior.prototype.refresh = function (content) {\n    var _a = this.options.rect,\n        size = _a.size,\n        position = _a.position;\n    var isWrapperStatic = window.getComputedStyle(this.wrapper, null).position === 'static'; // Force reflow\n\n    var wrapperRect = getRect(this.wrapper); // use client is more fair than offset\n\n    this.wrapperSize = this.wrapper[size === 'width' ? 'clientWidth' : 'clientHeight'];\n    this.setContent(content);\n    var contentRect = getRect(this.content);\n    this.contentSize = contentRect[size];\n    this.relativeOffset = contentRect[position];\n    /* istanbul ignore if  */\n\n    if (isWrapperStatic) {\n      this.relativeOffset -= wrapperRect[position];\n    }\n\n    this.computeBoundary();\n    this.setDirection(0\n    /* Default */\n    );\n  };\n\n  Behavior.prototype.setContent = function (content) {\n    if (content !== this.content) {\n      this.content = content;\n      this.resetState();\n    }\n  };\n\n  Behavior.prototype.resetState = function () {\n    this.currentPos = 0;\n    this.startPos = 0;\n    this.dist = 0;\n    this.setDirection(0\n    /* Default */\n    );\n    this.setMovingDirection(0\n    /* Default */\n    );\n    this.resetStartPos();\n  };\n\n  Behavior.prototype.computeBoundary = function () {\n    this.hooks.trigger(this.hooks.eventTypes.beforeComputeBoundary);\n    var boundary = {\n      minScrollPos: 0,\n      maxScrollPos: this.wrapperSize - this.contentSize\n    };\n\n    if (boundary.maxScrollPos < 0) {\n      boundary.maxScrollPos -= this.relativeOffset;\n\n      if (this.options.specifiedIndexAsContent === 0) {\n        boundary.minScrollPos = -this.relativeOffset;\n      }\n    }\n\n    this.hooks.trigger(this.hooks.eventTypes.computeBoundary, boundary);\n    this.minScrollPos = boundary.minScrollPos;\n    this.maxScrollPos = boundary.maxScrollPos;\n    this.hasScroll = this.options.scrollable && this.maxScrollPos < this.minScrollPos;\n\n    if (!this.hasScroll && this.minScrollPos < this.maxScrollPos) {\n      this.maxScrollPos = this.minScrollPos;\n      this.contentSize = this.wrapperSize;\n    }\n  };\n\n  Behavior.prototype.updatePosition = function (pos) {\n    this.currentPos = pos;\n  };\n\n  Behavior.prototype.getCurrentPos = function () {\n    return this.currentPos;\n  };\n\n  Behavior.prototype.checkInBoundary = function () {\n    var position = this.adjustPosition(this.currentPos);\n    var inBoundary = position === this.getCurrentPos();\n    return {\n      position: position,\n      inBoundary: inBoundary\n    };\n  }; // adjust position when out of boundary\n\n\n  Behavior.prototype.adjustPosition = function (pos) {\n    if (!this.hasScroll && !this.hooks.trigger(this.hooks.eventTypes.ignoreHasScroll)) {\n      pos = this.minScrollPos;\n    } else if (pos > this.minScrollPos) {\n      pos = this.minScrollPos;\n    } else if (pos < this.maxScrollPos) {\n      pos = this.maxScrollPos;\n    }\n\n    return pos;\n  };\n\n  Behavior.prototype.updateStartPos = function () {\n    this.startPos = this.currentPos;\n  };\n\n  Behavior.prototype.updateAbsStartPos = function () {\n    this.absStartPos = this.currentPos;\n  };\n\n  Behavior.prototype.resetStartPos = function () {\n    this.updateStartPos();\n    this.updateAbsStartPos();\n  };\n\n  Behavior.prototype.getAbsDist = function (delta) {\n    this.dist += delta;\n    return Math.abs(this.dist);\n  };\n\n  Behavior.prototype.destroy = function () {\n    this.hooks.destroy();\n  };\n\n  return Behavior;\n}();\n\nvar _a, _b, _c, _d;\n\nvar PassthroughHandlers = (_a = {}, _a[\"yes\"\n/* Yes */\n] = function (e) {\n  return true;\n}, _a[\"no\"\n/* No */\n] = function (e) {\n  maybePrevent(e);\n  return false;\n}, _a);\nvar DirectionMap = (_b = {}, _b[\"horizontal\"\n/* Horizontal */\n] = (_c = {}, _c[\"yes\"\n/* Yes */\n] = \"horizontal\"\n/* Horizontal */\n, _c[\"no\"\n/* No */\n] = \"vertical\"\n/* Vertical */\n, _c), _b[\"vertical\"\n/* Vertical */\n] = (_d = {}, _d[\"yes\"\n/* Yes */\n] = \"vertical\"\n/* Vertical */\n, _d[\"no\"\n/* No */\n] = \"horizontal\"\n/* Horizontal */\n, _d), _b);\n\nvar DirectionLockAction =\n/** @class */\nfunction () {\n  function DirectionLockAction(directionLockThreshold, freeScroll, eventPassthrough) {\n    this.directionLockThreshold = directionLockThreshold;\n    this.freeScroll = freeScroll;\n    this.eventPassthrough = eventPassthrough;\n    this.reset();\n  }\n\n  DirectionLockAction.prototype.reset = function () {\n    this.directionLocked = \"\"\n    /* Default */\n    ;\n  };\n\n  DirectionLockAction.prototype.checkMovingDirection = function (absDistX, absDistY, e) {\n    this.computeDirectionLock(absDistX, absDistY);\n    return this.handleEventPassthrough(e);\n  };\n\n  DirectionLockAction.prototype.adjustDelta = function (deltaX, deltaY) {\n    if (this.directionLocked === \"horizontal\"\n    /* Horizontal */\n    ) {\n      deltaY = 0;\n    } else if (this.directionLocked === \"vertical\"\n    /* Vertical */\n    ) {\n      deltaX = 0;\n    }\n\n    return {\n      deltaX: deltaX,\n      deltaY: deltaY\n    };\n  };\n\n  DirectionLockAction.prototype.computeDirectionLock = function (absDistX, absDistY) {\n    // If you are scrolling in one direction, lock it\n    if (this.directionLocked === \"\"\n    /* Default */\n    && !this.freeScroll) {\n      if (absDistX > absDistY + this.directionLockThreshold) {\n        this.directionLocked = \"horizontal\"\n        /* Horizontal */\n        ; // lock horizontally\n      } else if (absDistY >= absDistX + this.directionLockThreshold) {\n        this.directionLocked = \"vertical\"\n        /* Vertical */\n        ; // lock vertically\n      } else {\n        this.directionLocked = \"none\"\n        /* None */\n        ; // no lock\n      }\n    }\n  };\n\n  DirectionLockAction.prototype.handleEventPassthrough = function (e) {\n    var handleMap = DirectionMap[this.directionLocked];\n\n    if (handleMap) {\n      if (this.eventPassthrough === handleMap[\"yes\"\n      /* Yes */\n      ]) {\n        return PassthroughHandlers[\"yes\"\n        /* Yes */\n        ](e);\n      } else if (this.eventPassthrough === handleMap[\"no\"\n      /* No */\n      ]) {\n        return PassthroughHandlers[\"no\"\n        /* No */\n        ](e);\n      }\n    }\n\n    return false;\n  };\n\n  return DirectionLockAction;\n}();\n\nvar applyQuadrantTransformation = function (deltaX, deltaY, quadrant) {\n  if (quadrant === 2\n  /* Second */\n  ) {\n    return [deltaY, -deltaX];\n  } else if (quadrant === 3\n  /* Third */\n  ) {\n    return [-deltaX, -deltaY];\n  } else if (quadrant === 4\n  /* Forth */\n  ) {\n    return [-deltaY, deltaX];\n  } else {\n    return [deltaX, deltaY];\n  }\n};\n\nvar ScrollerActions =\n/** @class */\nfunction () {\n  function ScrollerActions(scrollBehaviorX, scrollBehaviorY, actionsHandler, animater, options) {\n    this.hooks = new EventEmitter(['start', 'beforeMove', 'scrollStart', 'scroll', 'beforeEnd', 'end', 'scrollEnd', 'contentNotMoved', 'detectMovingDirection', 'coordinateTransformation']);\n    this.scrollBehaviorX = scrollBehaviorX;\n    this.scrollBehaviorY = scrollBehaviorY;\n    this.actionsHandler = actionsHandler;\n    this.animater = animater;\n    this.options = options;\n    this.directionLockAction = new DirectionLockAction(options.directionLockThreshold, options.freeScroll, options.eventPassthrough);\n    this.enabled = true;\n    this.bindActionsHandler();\n  }\n\n  ScrollerActions.prototype.bindActionsHandler = function () {\n    var _this = this; // [mouse|touch]start event\n\n\n    this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.start, function (e) {\n      if (!_this.enabled) return true;\n      return _this.handleStart(e);\n    }); // [mouse|touch]move event\n\n    this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.move, function (_a) {\n      var deltaX = _a.deltaX,\n          deltaY = _a.deltaY,\n          e = _a.e;\n      if (!_this.enabled) return true;\n\n      var _b = applyQuadrantTransformation(deltaX, deltaY, _this.options.quadrant),\n          transformateDeltaX = _b[0],\n          transformateDeltaY = _b[1];\n\n      var transformateDeltaData = {\n        deltaX: transformateDeltaX,\n        deltaY: transformateDeltaY\n      };\n\n      _this.hooks.trigger(_this.hooks.eventTypes.coordinateTransformation, transformateDeltaData);\n\n      return _this.handleMove(transformateDeltaData.deltaX, transformateDeltaData.deltaY, e);\n    }); // [mouse|touch]end event\n\n    this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.end, function (e) {\n      if (!_this.enabled) return true;\n      return _this.handleEnd(e);\n    }); // click\n\n    this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.click, function (e) {\n      // handle native click event\n      if (_this.enabled && !e._constructed) {\n        _this.handleClick(e);\n      }\n    });\n  };\n\n  ScrollerActions.prototype.handleStart = function (e) {\n    var timestamp = getNow();\n    this.fingerMoved = false;\n    this.contentMoved = false;\n    this.startTime = timestamp;\n    this.directionLockAction.reset();\n    this.scrollBehaviorX.start();\n    this.scrollBehaviorY.start(); // force stopping last transition or animation\n\n    this.animater.doStop();\n    this.scrollBehaviorX.resetStartPos();\n    this.scrollBehaviorY.resetStartPos();\n    this.hooks.trigger(this.hooks.eventTypes.start, e);\n  };\n\n  ScrollerActions.prototype.handleMove = function (deltaX, deltaY, e) {\n    if (this.hooks.trigger(this.hooks.eventTypes.beforeMove, e)) {\n      return;\n    }\n\n    var absDistX = this.scrollBehaviorX.getAbsDist(deltaX);\n    var absDistY = this.scrollBehaviorY.getAbsDist(deltaY);\n    var timestamp = getNow(); // We need to move at least momentumLimitDistance pixels\n    // for the scrolling to initiate\n\n    if (this.checkMomentum(absDistX, absDistY, timestamp)) {\n      return true;\n    }\n\n    if (this.directionLockAction.checkMovingDirection(absDistX, absDistY, e)) {\n      this.actionsHandler.setInitiated();\n      return true;\n    }\n\n    var delta = this.directionLockAction.adjustDelta(deltaX, deltaY);\n    var prevX = this.scrollBehaviorX.getCurrentPos();\n    var newX = this.scrollBehaviorX.move(delta.deltaX);\n    var prevY = this.scrollBehaviorY.getCurrentPos();\n    var newY = this.scrollBehaviorY.move(delta.deltaY);\n\n    if (this.hooks.trigger(this.hooks.eventTypes.detectMovingDirection)) {\n      return;\n    }\n\n    if (!this.fingerMoved) {\n      this.fingerMoved = true;\n    }\n\n    var positionChanged = newX !== prevX || newY !== prevY;\n\n    if (!this.contentMoved && !positionChanged) {\n      this.hooks.trigger(this.hooks.eventTypes.contentNotMoved);\n    }\n\n    if (!this.contentMoved && positionChanged) {\n      this.contentMoved = true;\n      this.hooks.trigger(this.hooks.eventTypes.scrollStart);\n    }\n\n    if (this.contentMoved && positionChanged) {\n      this.animater.translate({\n        x: newX,\n        y: newY\n      });\n      this.dispatchScroll(timestamp);\n    }\n  };\n\n  ScrollerActions.prototype.dispatchScroll = function (timestamp) {\n    // dispatch scroll in interval time\n    if (timestamp - this.startTime > this.options.momentumLimitTime) {\n      // refresh time and starting position to initiate a momentum\n      this.startTime = timestamp;\n      this.scrollBehaviorX.updateStartPos();\n      this.scrollBehaviorY.updateStartPos();\n\n      if (this.options.probeType === 1\n      /* Throttle */\n      ) {\n        this.hooks.trigger(this.hooks.eventTypes.scroll, this.getCurrentPos());\n      }\n    } // dispatch scroll all the time\n\n\n    if (this.options.probeType > 1\n    /* Throttle */\n    ) {\n      this.hooks.trigger(this.hooks.eventTypes.scroll, this.getCurrentPos());\n    }\n  };\n\n  ScrollerActions.prototype.checkMomentum = function (absDistX, absDistY, timestamp) {\n    return timestamp - this.endTime > this.options.momentumLimitTime && absDistY < this.options.momentumLimitDistance && absDistX < this.options.momentumLimitDistance;\n  };\n\n  ScrollerActions.prototype.handleEnd = function (e) {\n    if (this.hooks.trigger(this.hooks.eventTypes.beforeEnd, e)) {\n      return;\n    }\n\n    var currentPos = this.getCurrentPos();\n    this.scrollBehaviorX.updateDirection();\n    this.scrollBehaviorY.updateDirection();\n\n    if (this.hooks.trigger(this.hooks.eventTypes.end, e, currentPos)) {\n      return true;\n    }\n\n    currentPos = this.ensureIntegerPos(currentPos);\n    this.animater.translate(currentPos);\n    this.endTime = getNow();\n    var duration = this.endTime - this.startTime;\n    this.hooks.trigger(this.hooks.eventTypes.scrollEnd, currentPos, duration);\n  };\n\n  ScrollerActions.prototype.ensureIntegerPos = function (currentPos) {\n    this.ensuringInteger = true;\n    var x = currentPos.x,\n        y = currentPos.y;\n    var _a = this.scrollBehaviorX,\n        minScrollPosX = _a.minScrollPos,\n        maxScrollPosX = _a.maxScrollPos;\n    var _b = this.scrollBehaviorY,\n        minScrollPosY = _b.minScrollPos,\n        maxScrollPosY = _b.maxScrollPos;\n    x = x > 0 ? Math.ceil(x) : Math.floor(x);\n    y = y > 0 ? Math.ceil(y) : Math.floor(y);\n    x = between(x, maxScrollPosX, minScrollPosX);\n    y = between(y, maxScrollPosY, minScrollPosY);\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  ScrollerActions.prototype.handleClick = function (e) {\n    if (!preventDefaultExceptionFn(e.target, this.options.preventDefaultException)) {\n      maybePrevent(e);\n      e.stopPropagation();\n    }\n  };\n\n  ScrollerActions.prototype.getCurrentPos = function () {\n    return {\n      x: this.scrollBehaviorX.getCurrentPos(),\n      y: this.scrollBehaviorY.getCurrentPos()\n    };\n  };\n\n  ScrollerActions.prototype.refresh = function () {\n    this.endTime = 0;\n  };\n\n  ScrollerActions.prototype.destroy = function () {\n    this.hooks.destroy();\n  };\n\n  return ScrollerActions;\n}();\n\nfunction createActionsHandlerOptions(bsOptions) {\n  var options = ['click', 'bindToWrapper', 'disableMouse', 'disableTouch', 'preventDefault', 'stopPropagation', 'tagException', 'preventDefaultException', 'autoEndDistance'].reduce(function (prev, cur) {\n    prev[cur] = bsOptions[cur];\n    return prev;\n  }, {});\n  return options;\n}\n\nfunction createBehaviorOptions(bsOptions, extraProp, bounces, rect) {\n  var options = ['momentum', 'momentumLimitTime', 'momentumLimitDistance', 'deceleration', 'swipeBounceTime', 'swipeTime', 'outOfBoundaryDampingFactor', 'specifiedIndexAsContent'].reduce(function (prev, cur) {\n    prev[cur] = bsOptions[cur];\n    return prev;\n  }, {}); // add extra property\n\n  options.scrollable = !!bsOptions[extraProp];\n  options.bounces = bounces;\n  options.rect = rect;\n  return options;\n}\n\nfunction bubbling(source, target, events) {\n  events.forEach(function (event) {\n    var sourceEvent;\n    var targetEvent;\n\n    if (typeof event === 'string') {\n      sourceEvent = targetEvent = event;\n    } else {\n      sourceEvent = event.source;\n      targetEvent = event.target;\n    }\n\n    source.on(sourceEvent, function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return target.trigger.apply(target, __spreadArrays([targetEvent], args));\n    });\n  });\n}\n\nfunction isSamePoint(startPoint, endPoint) {\n  // keys of startPoint and endPoint should be equal\n  var keys = Object.keys(startPoint);\n\n  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n    var key = keys_1[_i];\n    if (startPoint[key] !== endPoint[key]) return false;\n  }\n\n  return true;\n}\n\nvar MIN_SCROLL_DISTANCE = 1;\n\nvar Scroller =\n/** @class */\nfunction () {\n  function Scroller(wrapper, content, options) {\n    this.wrapper = wrapper;\n    this.content = content;\n    this.resizeTimeout = 0;\n    this.hooks = new EventEmitter(['beforeStart', 'beforeMove', 'beforeScrollStart', 'scrollStart', 'scroll', 'beforeEnd', 'scrollEnd', 'resize', 'touchEnd', 'end', 'flick', 'scrollCancel', 'momentum', 'scrollTo', 'minDistanceScroll', 'scrollToElement', 'beforeRefresh']);\n    this.options = options;\n    var _a = this.options.bounce,\n        left = _a.left,\n        right = _a.right,\n        top = _a.top,\n        bottom = _a.bottom; // direction X\n\n    this.scrollBehaviorX = new Behavior(wrapper, content, createBehaviorOptions(options, 'scrollX', [left, right], {\n      size: 'width',\n      position: 'left'\n    })); // direction Y\n\n    this.scrollBehaviorY = new Behavior(wrapper, content, createBehaviorOptions(options, 'scrollY', [top, bottom], {\n      size: 'height',\n      position: 'top'\n    }));\n    this.translater = new Translater(this.content);\n    this.animater = createAnimater(this.content, this.translater, this.options);\n    this.actionsHandler = new ActionsHandler(this.options.bindToTarget ? this.content : wrapper, createActionsHandlerOptions(this.options));\n    this.actions = new ScrollerActions(this.scrollBehaviorX, this.scrollBehaviorY, this.actionsHandler, this.animater, this.options);\n    var resizeHandler = this.resize.bind(this);\n    this.resizeRegister = new EventRegister(window, [{\n      name: 'orientationchange',\n      handler: resizeHandler\n    }, {\n      name: 'resize',\n      handler: resizeHandler\n    }]);\n    this.registerTransitionEnd();\n    this.init();\n  }\n\n  Scroller.prototype.init = function () {\n    var _this = this;\n\n    this.bindTranslater();\n    this.bindAnimater();\n    this.bindActions(); // enable pointer events when scrolling ends\n\n    this.hooks.on(this.hooks.eventTypes.scrollEnd, function () {\n      _this.togglePointerEvents(true);\n    });\n  };\n\n  Scroller.prototype.registerTransitionEnd = function () {\n    this.transitionEndRegister = new EventRegister(this.content, [{\n      name: style.transitionEnd,\n      handler: this.transitionEnd.bind(this)\n    }]);\n  };\n\n  Scroller.prototype.bindTranslater = function () {\n    var _this = this;\n\n    var hooks = this.translater.hooks;\n    hooks.on(hooks.eventTypes.beforeTranslate, function (transformStyle) {\n      if (_this.options.translateZ) {\n        transformStyle.push(_this.options.translateZ);\n      }\n    }); // disable pointer events when scrolling\n\n    hooks.on(hooks.eventTypes.translate, function (pos) {\n      var prevPos = _this.getCurrentPos();\n\n      _this.updatePositions(pos); // scrollEnd will dispatch when scroll is force stopping in touchstart handler\n      // so in touchend handler, don't toggle pointer-events\n\n\n      if (_this.actions.ensuringInteger === true) {\n        _this.actions.ensuringInteger = false;\n        return;\n      } // a valid translate\n\n\n      if (pos.x !== prevPos.x || pos.y !== prevPos.y) {\n        _this.togglePointerEvents(false);\n      }\n    });\n  };\n\n  Scroller.prototype.bindAnimater = function () {\n    var _this = this; // reset position\n\n\n    this.animater.hooks.on(this.animater.hooks.eventTypes.end, function (pos) {\n      if (!_this.resetPosition(_this.options.bounceTime)) {\n        _this.animater.setPending(false);\n\n        _this.hooks.trigger(_this.hooks.eventTypes.scrollEnd, pos);\n      }\n    });\n    bubbling(this.animater.hooks, this.hooks, [{\n      source: this.animater.hooks.eventTypes.move,\n      target: this.hooks.eventTypes.scroll\n    }, {\n      source: this.animater.hooks.eventTypes.forceStop,\n      target: this.hooks.eventTypes.scrollEnd\n    }]);\n  };\n\n  Scroller.prototype.bindActions = function () {\n    var _this = this;\n\n    var actions = this.actions;\n    bubbling(actions.hooks, this.hooks, [{\n      source: actions.hooks.eventTypes.start,\n      target: this.hooks.eventTypes.beforeStart\n    }, {\n      source: actions.hooks.eventTypes.start,\n      target: this.hooks.eventTypes.beforeScrollStart\n    }, {\n      source: actions.hooks.eventTypes.beforeMove,\n      target: this.hooks.eventTypes.beforeMove\n    }, {\n      source: actions.hooks.eventTypes.scrollStart,\n      target: this.hooks.eventTypes.scrollStart\n    }, {\n      source: actions.hooks.eventTypes.scroll,\n      target: this.hooks.eventTypes.scroll\n    }, {\n      source: actions.hooks.eventTypes.beforeEnd,\n      target: this.hooks.eventTypes.beforeEnd\n    }]);\n    actions.hooks.on(actions.hooks.eventTypes.end, function (e, pos) {\n      _this.hooks.trigger(_this.hooks.eventTypes.touchEnd, pos);\n\n      if (_this.hooks.trigger(_this.hooks.eventTypes.end, pos)) {\n        return true;\n      } // check if it is a click operation\n\n\n      if (!actions.fingerMoved) {\n        _this.hooks.trigger(_this.hooks.eventTypes.scrollCancel);\n\n        if (_this.checkClick(e)) {\n          return true;\n        }\n      } // reset if we are outside of the boundaries\n\n\n      if (_this.resetPosition(_this.options.bounceTime, ease.bounce)) {\n        _this.animater.setForceStopped(false);\n\n        return true;\n      }\n    });\n    actions.hooks.on(actions.hooks.eventTypes.scrollEnd, function (pos, duration) {\n      var deltaX = Math.abs(pos.x - _this.scrollBehaviorX.startPos);\n      var deltaY = Math.abs(pos.y - _this.scrollBehaviorY.startPos);\n\n      if (_this.checkFlick(duration, deltaX, deltaY)) {\n        _this.animater.setForceStopped(false);\n\n        _this.hooks.trigger(_this.hooks.eventTypes.flick);\n\n        return;\n      }\n\n      if (_this.momentum(pos, duration)) {\n        _this.animater.setForceStopped(false);\n\n        return;\n      }\n\n      if (actions.contentMoved) {\n        _this.hooks.trigger(_this.hooks.eventTypes.scrollEnd, pos);\n      }\n\n      if (_this.animater.forceStopped) {\n        _this.animater.setForceStopped(false);\n      }\n    });\n  };\n\n  Scroller.prototype.checkFlick = function (duration, deltaX, deltaY) {\n    var flickMinMovingDistance = 1; // distinguish flick from click\n\n    if (this.hooks.events.flick.length > 1 && duration < this.options.flickLimitTime && deltaX < this.options.flickLimitDistance && deltaY < this.options.flickLimitDistance && (deltaY > flickMinMovingDistance || deltaX > flickMinMovingDistance)) {\n      return true;\n    }\n  };\n\n  Scroller.prototype.momentum = function (pos, duration) {\n    var meta = {\n      time: 0,\n      easing: ease.swiper,\n      newX: pos.x,\n      newY: pos.y\n    }; // start momentum animation if needed\n\n    var momentumX = this.scrollBehaviorX.end(duration);\n    var momentumY = this.scrollBehaviorY.end(duration);\n    meta.newX = isUndef(momentumX.destination) ? meta.newX : momentumX.destination;\n    meta.newY = isUndef(momentumY.destination) ? meta.newY : momentumY.destination;\n    meta.time = Math.max(momentumX.duration, momentumY.duration);\n    this.hooks.trigger(this.hooks.eventTypes.momentum, meta, this); // when x or y changed, do momentum animation now!\n\n    if (meta.newX !== pos.x || meta.newY !== pos.y) {\n      // change easing function when scroller goes out of the boundaries\n      if (meta.newX > this.scrollBehaviorX.minScrollPos || meta.newX < this.scrollBehaviorX.maxScrollPos || meta.newY > this.scrollBehaviorY.minScrollPos || meta.newY < this.scrollBehaviorY.maxScrollPos) {\n        meta.easing = ease.swipeBounce;\n      }\n\n      this.scrollTo(meta.newX, meta.newY, meta.time, meta.easing);\n      return true;\n    }\n  };\n\n  Scroller.prototype.checkClick = function (e) {\n    var cancelable = {\n      preventClick: this.animater.forceStopped\n    }; // we scrolled less than momentumLimitDistance pixels\n\n    if (this.hooks.trigger(this.hooks.eventTypes.checkClick)) {\n      this.animater.setForceStopped(false);\n      return true;\n    }\n\n    if (!cancelable.preventClick) {\n      var _dblclick = this.options.dblclick;\n      var dblclickTrigged = false;\n\n      if (_dblclick && this.lastClickTime) {\n        var _a = _dblclick.delay,\n            delay = _a === void 0 ? 300 : _a;\n\n        if (getNow() - this.lastClickTime < delay) {\n          dblclickTrigged = true;\n          dblclick(e);\n        }\n      }\n\n      if (this.options.tap) {\n        tap(e, this.options.tap);\n      }\n\n      if (this.options.click && !preventDefaultExceptionFn(e.target, this.options.preventDefaultException)) {\n        click(e);\n      }\n\n      this.lastClickTime = dblclickTrigged ? null : getNow();\n      return true;\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.resize = function () {\n    var _this = this;\n\n    if (!this.actions.enabled) {\n      return;\n    } // fix a scroll problem under Android condition\n\n    /* istanbul ignore if  */\n\n\n    if (isAndroid) {\n      this.wrapper.scrollTop = 0;\n    }\n\n    clearTimeout(this.resizeTimeout);\n    this.resizeTimeout = window.setTimeout(function () {\n      _this.hooks.trigger(_this.hooks.eventTypes.resize);\n    }, this.options.resizePolling);\n  };\n  /* istanbul ignore next */\n\n\n  Scroller.prototype.transitionEnd = function (e) {\n    if (e.target !== this.content || !this.animater.pending) {\n      return;\n    }\n\n    var animater = this.animater;\n    animater.transitionTime();\n\n    if (!this.resetPosition(this.options.bounceTime, ease.bounce)) {\n      this.animater.setPending(false);\n\n      if (this.options.probeType !== 3\n      /* Realtime */\n      ) {\n        this.hooks.trigger(this.hooks.eventTypes.scrollEnd, this.getCurrentPos());\n      }\n    }\n  };\n\n  Scroller.prototype.togglePointerEvents = function (enabled) {\n    if (enabled === void 0) {\n      enabled = true;\n    }\n\n    var el = this.content.children.length ? this.content.children : [this.content];\n    var pointerEvents = enabled ? 'auto' : 'none';\n\n    for (var i = 0; i < el.length; i++) {\n      var node = el[i]; // ignore BetterScroll instance's wrapper DOM\n\n      /* istanbul ignore if  */\n\n      if (node.isBScrollContainer) {\n        continue;\n      }\n\n      node.style.pointerEvents = pointerEvents;\n    }\n  };\n\n  Scroller.prototype.refresh = function (content) {\n    var contentChanged = this.setContent(content);\n    this.hooks.trigger(this.hooks.eventTypes.beforeRefresh);\n    this.scrollBehaviorX.refresh(content);\n    this.scrollBehaviorY.refresh(content);\n\n    if (contentChanged) {\n      this.translater.setContent(content);\n      this.animater.setContent(content);\n      this.transitionEndRegister.destroy();\n      this.registerTransitionEnd();\n\n      if (this.options.bindToTarget) {\n        this.actionsHandler.setContent(content);\n      }\n    }\n\n    this.actions.refresh();\n    this.wrapperOffset = offset(this.wrapper);\n  };\n\n  Scroller.prototype.setContent = function (content) {\n    var contentChanged = content !== this.content;\n\n    if (contentChanged) {\n      this.content = content;\n    }\n\n    return contentChanged;\n  };\n\n  Scroller.prototype.scrollBy = function (deltaX, deltaY, time, easing) {\n    if (time === void 0) {\n      time = 0;\n    }\n\n    var _a = this.getCurrentPos(),\n        x = _a.x,\n        y = _a.y;\n\n    easing = !easing ? ease.bounce : easing;\n    deltaX += x;\n    deltaY += y;\n    this.scrollTo(deltaX, deltaY, time, easing);\n  };\n\n  Scroller.prototype.scrollTo = function (x, y, time, easing, extraTransform) {\n    if (time === void 0) {\n      time = 0;\n    }\n\n    if (easing === void 0) {\n      easing = ease.bounce;\n    }\n\n    if (extraTransform === void 0) {\n      extraTransform = {\n        start: {},\n        end: {}\n      };\n    }\n\n    var easingFn = this.options.useTransition ? easing.style : easing.fn;\n    var currentPos = this.getCurrentPos();\n\n    var startPoint = __assign({\n      x: currentPos.x,\n      y: currentPos.y\n    }, extraTransform.start);\n\n    var endPoint = __assign({\n      x: x,\n      y: y\n    }, extraTransform.end);\n\n    this.hooks.trigger(this.hooks.eventTypes.scrollTo, endPoint); // it is an useless move\n\n    if (isSamePoint(startPoint, endPoint)) return;\n    var deltaX = Math.abs(endPoint.x - startPoint.x);\n    var deltaY = Math.abs(endPoint.y - startPoint.y); // considering of browser compatibility for decimal transform value\n    // force translating immediately\n\n    if (deltaX < MIN_SCROLL_DISTANCE && deltaY < MIN_SCROLL_DISTANCE) {\n      time = 0;\n      this.hooks.trigger(this.hooks.eventTypes.minDistanceScroll);\n    }\n\n    this.animater.move(startPoint, endPoint, time, easingFn);\n  };\n\n  Scroller.prototype.scrollToElement = function (el, time, offsetX, offsetY, easing) {\n    var targetEle = getElement(el);\n    var pos = offset(targetEle);\n\n    var getOffset = function (offset, size, wrapperSize) {\n      if (typeof offset === 'number') {\n        return offset;\n      } // if offsetX/Y are true we center the element to the screen\n\n\n      return offset ? Math.round(size / 2 - wrapperSize / 2) : 0;\n    };\n\n    offsetX = getOffset(offsetX, targetEle.offsetWidth, this.wrapper.offsetWidth);\n    offsetY = getOffset(offsetY, targetEle.offsetHeight, this.wrapper.offsetHeight);\n\n    var getPos = function (pos, wrapperPos, offset, scrollBehavior) {\n      pos -= wrapperPos;\n      pos = scrollBehavior.adjustPosition(pos - offset);\n      return pos;\n    };\n\n    pos.left = getPos(pos.left, this.wrapperOffset.left, offsetX, this.scrollBehaviorX);\n    pos.top = getPos(pos.top, this.wrapperOffset.top, offsetY, this.scrollBehaviorY);\n\n    if (this.hooks.trigger(this.hooks.eventTypes.scrollToElement, targetEle, pos)) {\n      return;\n    }\n\n    this.scrollTo(pos.left, pos.top, time, easing);\n  };\n\n  Scroller.prototype.resetPosition = function (time, easing) {\n    if (time === void 0) {\n      time = 0;\n    }\n\n    if (easing === void 0) {\n      easing = ease.bounce;\n    }\n\n    var _a = this.scrollBehaviorX.checkInBoundary(),\n        x = _a.position,\n        xInBoundary = _a.inBoundary;\n\n    var _b = this.scrollBehaviorY.checkInBoundary(),\n        y = _b.position,\n        yInBoundary = _b.inBoundary;\n\n    if (xInBoundary && yInBoundary) {\n      return false;\n    }\n    /* istanbul ignore if  */\n\n\n    if (isIOSBadVersion) {\n      // fix ios 13.4 bouncing\n      // see it in issues 982\n      this.reflow();\n    } // out of boundary\n\n\n    this.scrollTo(x, y, time, easing);\n    return true;\n  };\n  /* istanbul ignore next */\n\n\n  Scroller.prototype.reflow = function () {\n    this._reflow = this.content.offsetHeight;\n  };\n\n  Scroller.prototype.updatePositions = function (pos) {\n    this.scrollBehaviorX.updatePosition(pos.x);\n    this.scrollBehaviorY.updatePosition(pos.y);\n  };\n\n  Scroller.prototype.getCurrentPos = function () {\n    return this.actions.getCurrentPos();\n  };\n\n  Scroller.prototype.enable = function () {\n    this.actions.enabled = true;\n  };\n\n  Scroller.prototype.disable = function () {\n    cancelAnimationFrame(this.animater.timer);\n    this.actions.enabled = false;\n  };\n\n  Scroller.prototype.destroy = function () {\n    var _this = this;\n\n    var keys = ['resizeRegister', 'transitionEndRegister', 'actionsHandler', 'actions', 'hooks', 'animater', 'translater', 'scrollBehaviorX', 'scrollBehaviorY'];\n    keys.forEach(function (key) {\n      return _this[key].destroy();\n    });\n  };\n\n  return Scroller;\n}();\n\nvar BScrollConstructor =\n/** @class */\nfunction (_super) {\n  __extends(BScrollConstructor, _super);\n\n  function BScrollConstructor(el, options) {\n    var _this = _super.call(this, ['refresh', 'contentChanged', 'enable', 'disable', 'beforeScrollStart', 'scrollStart', 'scroll', 'scrollEnd', 'scrollCancel', 'touchEnd', 'flick', 'destroy']) || this;\n\n    var wrapper = getElement(el);\n\n    if (!wrapper) {\n      warn('Can not resolve the wrapper DOM.');\n      return _this;\n    }\n\n    _this.plugins = {};\n    _this.options = new OptionsConstructor().merge(options).process();\n\n    if (!_this.setContent(wrapper).valid) {\n      return _this;\n    }\n\n    _this.hooks = new EventEmitter(['refresh', 'enable', 'disable', 'destroy', 'beforeInitialScrollTo', 'contentChanged']);\n\n    _this.init(wrapper);\n\n    return _this;\n  }\n\n  BScrollConstructor.use = function (ctor) {\n    var name = ctor.pluginName;\n    var installed = BScrollConstructor.plugins.some(function (plugin) {\n      return ctor === plugin.ctor;\n    });\n    if (installed) return BScrollConstructor;\n\n    if (isUndef(name)) {\n      warn(\"Plugin Class must specify plugin's name in static property by 'pluginName' field.\");\n      return BScrollConstructor;\n    }\n\n    BScrollConstructor.pluginsMap[name] = true;\n    BScrollConstructor.plugins.push({\n      name: name,\n      applyOrder: ctor.applyOrder,\n      ctor: ctor\n    });\n    return BScrollConstructor;\n  };\n\n  BScrollConstructor.prototype.setContent = function (wrapper) {\n    var contentChanged = false;\n    var valid = true;\n    var content = wrapper.children[this.options.specifiedIndexAsContent];\n\n    if (!content) {\n      warn('The wrapper need at least one child element to be content element to scroll.');\n      valid = false;\n    } else {\n      contentChanged = this.content !== content;\n\n      if (contentChanged) {\n        this.content = content;\n      }\n    }\n\n    return {\n      valid: valid,\n      contentChanged: contentChanged\n    };\n  };\n\n  BScrollConstructor.prototype.init = function (wrapper) {\n    var _this = this;\n\n    this.wrapper = wrapper; // mark wrapper to recognize bs instance by DOM attribute\n\n    wrapper.isBScrollContainer = true;\n    this.scroller = new Scroller(wrapper, this.content, this.options);\n    this.scroller.hooks.on(this.scroller.hooks.eventTypes.resize, function () {\n      _this.refresh();\n    });\n    this.eventBubbling();\n    this.handleAutoBlur();\n    this.enable();\n    this.proxy(propertiesConfig$7);\n    this.applyPlugins(); // maybe boundary has changed, should refresh\n\n    this.refreshWithoutReset(this.content);\n    var _a = this.options,\n        startX = _a.startX,\n        startY = _a.startY;\n    var position = {\n      x: startX,\n      y: startY\n    }; // maybe plugins want to control scroll position\n\n    if (this.hooks.trigger(this.hooks.eventTypes.beforeInitialScrollTo, position)) {\n      return;\n    }\n\n    this.scroller.scrollTo(position.x, position.y);\n  };\n\n  BScrollConstructor.prototype.applyPlugins = function () {\n    var _this = this;\n\n    var options = this.options;\n    BScrollConstructor.plugins.sort(function (a, b) {\n      var _a;\n\n      var applyOrderMap = (_a = {}, _a[\"pre\"\n      /* Pre */\n      ] = -1, _a[\"post\"\n      /* Post */\n      ] = 1, _a);\n      var aOrder = a.applyOrder ? applyOrderMap[a.applyOrder] : 0;\n      var bOrder = b.applyOrder ? applyOrderMap[b.applyOrder] : 0;\n      return aOrder - bOrder;\n    }).forEach(function (item) {\n      var ctor = item.ctor;\n\n      if (options[item.name] && typeof ctor === 'function') {\n        _this.plugins[item.name] = new ctor(_this);\n      }\n    });\n  };\n\n  BScrollConstructor.prototype.handleAutoBlur = function () {\n    /* istanbul ignore if  */\n    if (this.options.autoBlur) {\n      this.on(this.eventTypes.beforeScrollStart, function () {\n        var activeElement = document.activeElement;\n\n        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {\n          activeElement.blur();\n        }\n      });\n    }\n  };\n\n  BScrollConstructor.prototype.eventBubbling = function () {\n    bubbling(this.scroller.hooks, this, [this.eventTypes.beforeScrollStart, this.eventTypes.scrollStart, this.eventTypes.scroll, this.eventTypes.scrollEnd, this.eventTypes.scrollCancel, this.eventTypes.touchEnd, this.eventTypes.flick]);\n  };\n\n  BScrollConstructor.prototype.refreshWithoutReset = function (content) {\n    this.scroller.refresh(content);\n    this.hooks.trigger(this.hooks.eventTypes.refresh, content);\n    this.trigger(this.eventTypes.refresh, content);\n  };\n\n  BScrollConstructor.prototype.proxy = function (propertiesConfig) {\n    var _this = this;\n\n    propertiesConfig.forEach(function (_a) {\n      var key = _a.key,\n          sourceKey = _a.sourceKey;\n      propertiesProxy(_this, sourceKey, key);\n    });\n  };\n\n  BScrollConstructor.prototype.refresh = function () {\n    var _a = this.setContent(this.wrapper),\n        contentChanged = _a.contentChanged,\n        valid = _a.valid;\n\n    if (valid) {\n      var content = this.content;\n      this.refreshWithoutReset(content);\n\n      if (contentChanged) {\n        this.hooks.trigger(this.hooks.eventTypes.contentChanged, content);\n        this.trigger(this.eventTypes.contentChanged, content);\n      }\n\n      this.scroller.resetPosition();\n    }\n  };\n\n  BScrollConstructor.prototype.enable = function () {\n    this.scroller.enable();\n    this.hooks.trigger(this.hooks.eventTypes.enable);\n    this.trigger(this.eventTypes.enable);\n  };\n\n  BScrollConstructor.prototype.disable = function () {\n    this.scroller.disable();\n    this.hooks.trigger(this.hooks.eventTypes.disable);\n    this.trigger(this.eventTypes.disable);\n  };\n\n  BScrollConstructor.prototype.destroy = function () {\n    this.hooks.trigger(this.hooks.eventTypes.destroy);\n    this.trigger(this.eventTypes.destroy);\n    this.scroller.destroy();\n  };\n\n  BScrollConstructor.prototype.eventRegister = function (names) {\n    this.registerType(names);\n  };\n\n  BScrollConstructor.plugins = [];\n  BScrollConstructor.pluginsMap = {};\n  return BScrollConstructor;\n}(EventEmitter);\n\nfunction createBScroll(el, options) {\n  var bs = new BScrollConstructor(el, options);\n  return bs;\n}\n\ncreateBScroll.use = BScrollConstructor.use;\ncreateBScroll.plugins = BScrollConstructor.plugins;\ncreateBScroll.pluginsMap = BScrollConstructor.pluginsMap;\nvar BScroll = createBScroll;\n\nvar MouseWheel =\n/** @class */\nfunction () {\n  function MouseWheel(scroll) {\n    this.scroll = scroll;\n    this.wheelEndTimer = 0;\n    this.wheelMoveTimer = 0;\n    this.wheelStart = false;\n    this.init();\n  }\n\n  MouseWheel.prototype.init = function () {\n    this.handleBScroll();\n    this.handleOptions();\n    this.handleHooks();\n    this.registerEvent();\n  };\n\n  MouseWheel.prototype.handleBScroll = function () {\n    this.scroll.registerType(['alterOptions', 'mousewheelStart', 'mousewheelMove', 'mousewheelEnd']);\n  };\n\n  MouseWheel.prototype.handleOptions = function () {\n    var userOptions = this.scroll.options.mouseWheel === true ? {} : this.scroll.options.mouseWheel;\n    var defaultOptions = {\n      speed: 20,\n      invert: false,\n      easeTime: 300,\n      discreteTime: 400,\n      throttleTime: 0,\n      dampingFactor: 0.1\n    };\n    this.mouseWheelOpt = extend(defaultOptions, userOptions);\n  };\n\n  MouseWheel.prototype.handleHooks = function () {\n    this.hooksFn = [];\n    this.registerHooks(this.scroll.hooks, 'destroy', this.destroy);\n  };\n\n  MouseWheel.prototype.registerEvent = function () {\n    this.eventRegister = new EventRegister(this.scroll.scroller.wrapper, [{\n      name: 'wheel',\n      handler: this.wheelHandler.bind(this)\n    }, {\n      name: 'mousewheel',\n      handler: this.wheelHandler.bind(this)\n    }, {\n      name: 'DOMMouseScroll',\n      handler: this.wheelHandler.bind(this)\n    }]);\n  };\n\n  MouseWheel.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  MouseWheel.prototype.wheelHandler = function (e) {\n    if (!this.scroll.enabled) {\n      return;\n    }\n\n    this.beforeHandler(e); // start\n\n    if (!this.wheelStart) {\n      this.wheelStartHandler(e);\n      this.wheelStart = true;\n    } // move\n\n\n    var delta = this.getWheelDelta(e);\n    this.wheelMoveHandler(delta); // end\n\n    this.wheelEndDetector(delta);\n  };\n\n  MouseWheel.prototype.wheelStartHandler = function (e) {\n    this.cleanCache();\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n    scrollBehaviorX.setMovingDirection(0\n    /* Default */\n    );\n    scrollBehaviorY.setMovingDirection(0\n    /* Default */\n    );\n    scrollBehaviorX.setDirection(0\n    /* Default */\n    );\n    scrollBehaviorY.setDirection(0\n    /* Default */\n    );\n    this.scroll.trigger(this.scroll.eventTypes.alterOptions, this.mouseWheelOpt);\n    this.scroll.trigger(this.scroll.eventTypes.mousewheelStart);\n  };\n\n  MouseWheel.prototype.cleanCache = function () {\n    this.deltaCache = [];\n  };\n\n  MouseWheel.prototype.wheelMoveHandler = function (delta) {\n    var _this = this;\n\n    var _a = this.mouseWheelOpt,\n        throttleTime = _a.throttleTime,\n        dampingFactor = _a.dampingFactor;\n\n    if (throttleTime && this.wheelMoveTimer) {\n      this.deltaCache.push(delta);\n    } else {\n      var cachedDelta = this.deltaCache.reduce(function (prev, current) {\n        return {\n          x: prev.x + current.x,\n          y: prev.y + current.y\n        };\n      }, {\n        x: 0,\n        y: 0\n      });\n      this.cleanCache();\n      var _b = this.scroll.scroller,\n          scrollBehaviorX = _b.scrollBehaviorX,\n          scrollBehaviorY = _b.scrollBehaviorY;\n      scrollBehaviorX.setMovingDirection(-delta.directionX);\n      scrollBehaviorY.setMovingDirection(-delta.directionY);\n      scrollBehaviorX.setDirection(delta.x);\n      scrollBehaviorY.setDirection(delta.y); // when out of boundary, perform a damping scroll\n\n      var newX = scrollBehaviorX.performDampingAlgorithm(Math.round(delta.x) + cachedDelta.x, dampingFactor);\n      var newY = scrollBehaviorY.performDampingAlgorithm(Math.round(delta.y) + cachedDelta.x, dampingFactor);\n\n      if (!this.scroll.trigger(this.scroll.eventTypes.mousewheelMove, {\n        x: newX,\n        y: newY\n      })) {\n        var easeTime = this.getEaseTime();\n\n        if (newX !== this.scroll.x || newY !== this.scroll.y) {\n          this.scroll.scrollTo(newX, newY, easeTime);\n        }\n      }\n\n      if (throttleTime) {\n        this.wheelMoveTimer = window.setTimeout(function () {\n          _this.wheelMoveTimer = 0;\n        }, throttleTime);\n      }\n    }\n  };\n\n  MouseWheel.prototype.wheelEndDetector = function (delta) {\n    var _this = this;\n\n    window.clearTimeout(this.wheelEndTimer);\n    this.wheelEndTimer = window.setTimeout(function () {\n      _this.wheelStart = false;\n      window.clearTimeout(_this.wheelMoveTimer);\n      _this.wheelMoveTimer = 0;\n\n      _this.scroll.trigger(_this.scroll.eventTypes.mousewheelEnd, delta);\n    }, this.mouseWheelOpt.discreteTime);\n  };\n\n  MouseWheel.prototype.getWheelDelta = function (e) {\n    var _a = this.mouseWheelOpt,\n        speed = _a.speed,\n        invert = _a.invert;\n    var wheelDeltaX = 0;\n    var wheelDeltaY = 0;\n    var direction = invert ? -1\n    /* Negative */\n    : 1\n    /* Positive */\n    ;\n\n    switch (true) {\n      case 'deltaX' in e:\n        if (e.deltaMode === 1) {\n          wheelDeltaX = -e.deltaX * speed;\n          wheelDeltaY = -e.deltaY * speed;\n        } else {\n          wheelDeltaX = -e.deltaX;\n          wheelDeltaY = -e.deltaY;\n        }\n\n        break;\n\n      case 'wheelDeltaX' in e:\n        wheelDeltaX = e.wheelDeltaX / 120 * speed;\n        wheelDeltaY = e.wheelDeltaY / 120 * speed;\n        break;\n\n      case 'wheelDelta' in e:\n        wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * speed;\n        break;\n\n      case 'detail' in e:\n        wheelDeltaX = wheelDeltaY = -e.detail / 3 * speed;\n        break;\n    }\n\n    wheelDeltaX *= direction;\n    wheelDeltaY *= direction;\n\n    if (!this.scroll.hasVerticalScroll) {\n      if (Math.abs(wheelDeltaY) > Math.abs(wheelDeltaX)) {\n        wheelDeltaX = wheelDeltaY;\n      }\n\n      wheelDeltaY = 0;\n    }\n\n    if (!this.scroll.hasHorizontalScroll) {\n      wheelDeltaX = 0;\n    }\n\n    var directionX = wheelDeltaX > 0 ? -1\n    /* Negative */\n    : wheelDeltaX < 0 ? 1\n    /* Positive */\n    : 0\n    /* Default */\n    ;\n    var directionY = wheelDeltaY > 0 ? -1\n    /* Negative */\n    : wheelDeltaY < 0 ? 1\n    /* Positive */\n    : 0\n    /* Default */\n    ;\n    return {\n      x: wheelDeltaX,\n      y: wheelDeltaY,\n      directionX: directionX,\n      directionY: directionY\n    };\n  };\n\n  MouseWheel.prototype.beforeHandler = function (e) {\n    var _a = this.scroll.options,\n        preventDefault = _a.preventDefault,\n        stopPropagation = _a.stopPropagation,\n        preventDefaultException = _a.preventDefaultException;\n\n    if (preventDefault && !preventDefaultExceptionFn(e.target, preventDefaultException)) {\n      maybePrevent(e);\n    }\n\n    if (stopPropagation) {\n      e.stopPropagation();\n    }\n  };\n\n  MouseWheel.prototype.getEaseTime = function () {\n    var SAFE_EASETIME = 100;\n    var easeTime = this.mouseWheelOpt.easeTime; // scrollEnd event will be triggered in every calling of scrollTo when easeTime is too small\n    // easeTime needs to be greater than 100\n\n    if (easeTime < SAFE_EASETIME) {\n      warn(\"easeTime should be greater than 100.\" + \"If mouseWheel easeTime is too small,\" + \"scrollEnd will be triggered many times.\");\n    }\n\n    return Math.max(easeTime, SAFE_EASETIME);\n  };\n\n  MouseWheel.prototype.destroy = function () {\n    this.eventRegister.destroy();\n    window.clearTimeout(this.wheelEndTimer);\n    window.clearTimeout(this.wheelMoveTimer);\n    this.hooksFn.forEach(function (item) {\n      var hooks = item[0];\n      var hooksName = item[1];\n      var handlerFn = item[2];\n      hooks.off(hooksName, handlerFn);\n    });\n  };\n\n  MouseWheel.pluginName = 'mouseWheel';\n  MouseWheel.applyOrder = \"pre\"\n  /* Pre */\n  ;\n  return MouseWheel;\n}();\n\nvar ObserveDOM =\n/** @class */\nfunction () {\n  function ObserveDOM(scroll) {\n    this.scroll = scroll;\n    this.stopObserver = false;\n    this.init();\n  }\n\n  ObserveDOM.prototype.init = function () {\n    this.handleMutationObserver();\n    this.handleHooks();\n  };\n\n  ObserveDOM.prototype.handleMutationObserver = function () {\n    var _this = this;\n\n    if (typeof MutationObserver !== 'undefined') {\n      var timer_1 = 0;\n      this.observer = new MutationObserver(function (mutations) {\n        _this.mutationObserverHandler(mutations, timer_1);\n      });\n      this.startObserve(this.observer);\n    } else {\n      this.checkDOMUpdate();\n    }\n  };\n\n  ObserveDOM.prototype.handleHooks = function () {\n    var _this = this;\n\n    this.hooksFn = [];\n    this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.contentChanged, function () {\n      _this.stopObserve(); // launch a new mutationObserver\n\n\n      _this.handleMutationObserver();\n    });\n    this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.enable, function () {\n      if (_this.stopObserver) {\n        _this.handleMutationObserver();\n      }\n    });\n    this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.disable, function () {\n      _this.stopObserve();\n    });\n    this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.destroy, function () {\n      _this.destroy();\n    });\n  };\n\n  ObserveDOM.prototype.mutationObserverHandler = function (mutations, timer) {\n    var _this = this;\n\n    if (this.shouldNotRefresh()) {\n      return;\n    }\n\n    var immediateRefresh = false;\n    var deferredRefresh = false;\n\n    for (var i = 0; i < mutations.length; i++) {\n      var mutation = mutations[i];\n\n      if (mutation.type !== 'attributes') {\n        immediateRefresh = true;\n        break;\n      } else {\n        if (mutation.target !== this.scroll.scroller.content) {\n          deferredRefresh = true;\n          break;\n        }\n      }\n    }\n\n    if (immediateRefresh) {\n      this.scroll.refresh();\n    } else if (deferredRefresh) {\n      // attributes changes too often\n      clearTimeout(timer);\n      timer = window.setTimeout(function () {\n        if (!_this.shouldNotRefresh()) {\n          _this.scroll.refresh();\n        }\n      }, 60);\n    }\n  };\n\n  ObserveDOM.prototype.startObserve = function (observer) {\n    var config = {\n      attributes: true,\n      childList: true,\n      subtree: true\n    };\n    observer.observe(this.scroll.scroller.content, config);\n  };\n\n  ObserveDOM.prototype.shouldNotRefresh = function () {\n    var scroller = this.scroll.scroller;\n    var scrollBehaviorX = scroller.scrollBehaviorX,\n        scrollBehaviorY = scroller.scrollBehaviorY;\n    var outsideBoundaries = scrollBehaviorX.currentPos > scrollBehaviorX.minScrollPos || scrollBehaviorX.currentPos < scrollBehaviorX.maxScrollPos || scrollBehaviorY.currentPos > scrollBehaviorY.minScrollPos || scrollBehaviorY.currentPos < scrollBehaviorY.maxScrollPos;\n    return scroller.animater.pending || outsideBoundaries;\n  };\n\n  ObserveDOM.prototype.checkDOMUpdate = function () {\n    var _this = this;\n\n    var content = this.scroll.scroller.content;\n    var contentRect = getRect(content);\n    var oldWidth = contentRect.width;\n    var oldHeight = contentRect.height;\n\n    var check = function () {\n      if (_this.stopObserver) {\n        return;\n      }\n\n      contentRect = getRect(content);\n      var newWidth = contentRect.width;\n      var newHeight = contentRect.height;\n\n      if (oldWidth !== newWidth || oldHeight !== newHeight) {\n        _this.scroll.refresh();\n      }\n\n      oldWidth = newWidth;\n      oldHeight = newHeight;\n      next();\n    };\n\n    var next = function () {\n      setTimeout(function () {\n        check();\n      }, 1000);\n    };\n\n    next();\n  };\n\n  ObserveDOM.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  ObserveDOM.prototype.stopObserve = function () {\n    this.stopObserver = true;\n\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n  };\n\n  ObserveDOM.prototype.destroy = function () {\n    this.stopObserve();\n    this.hooksFn.forEach(function (item) {\n      var hooks = item[0];\n      var hooksName = item[1];\n      var handlerFn = item[2];\n      hooks.off(hooksName, handlerFn);\n    });\n    this.hooksFn.length = 0;\n  };\n\n  ObserveDOM.pluginName = 'observeDOM';\n  return ObserveDOM;\n}();\n\nvar sourcePrefix$6 = 'plugins.pullDownRefresh';\nvar propertiesMap$6 = [{\n  key: 'finishPullDown',\n  name: 'finishPullDown'\n}, {\n  key: 'openPullDown',\n  name: 'openPullDown'\n}, {\n  key: 'closePullDown',\n  name: 'closePullDown'\n}, {\n  key: 'autoPullDownRefresh',\n  name: 'autoPullDownRefresh'\n}];\nvar propertiesConfig$6 = propertiesMap$6.map(function (item) {\n  return {\n    key: item.key,\n    sourceKey: sourcePrefix$6 + \".\" + item.name\n  };\n});\nvar PULLING_DOWN_EVENT = 'pullingDown';\nvar ENTER_THRESHOLD_EVENT = 'enterThreshold';\nvar LEAVE_THRESHOLD_EVENT = 'leaveThreshold';\n\nvar PullDown =\n/** @class */\nfunction () {\n  function PullDown(scroll) {\n    this.scroll = scroll;\n    this.pulling = 0\n    /* DEFAULT */\n    ;\n    this.thresholdBoundary = 0\n    /* DEFAULT */\n    ;\n    this.init();\n  }\n\n  PullDown.prototype.setPulling = function (status) {\n    this.pulling = status;\n  };\n\n  PullDown.prototype.setThresholdBoundary = function (boundary) {\n    this.thresholdBoundary = boundary;\n  };\n\n  PullDown.prototype.init = function () {\n    this.handleBScroll();\n    this.handleOptions(this.scroll.options.pullDownRefresh);\n    this.handleHooks();\n    this.watch();\n  };\n\n  PullDown.prototype.handleBScroll = function () {\n    this.scroll.registerType([PULLING_DOWN_EVENT, ENTER_THRESHOLD_EVENT, LEAVE_THRESHOLD_EVENT]);\n    this.scroll.proxy(propertiesConfig$6);\n  };\n\n  PullDown.prototype.handleOptions = function (userOptions) {\n    if (userOptions === void 0) {\n      userOptions = {};\n    }\n\n    userOptions = userOptions === true ? {} : userOptions;\n    var defaultOptions = {\n      threshold: 90,\n      stop: 40\n    };\n    this.options = extend(defaultOptions, userOptions);\n    this.scroll.options.probeType = 3\n    /* Realtime */\n    ;\n  };\n\n  PullDown.prototype.handleHooks = function () {\n    var _this = this;\n\n    this.hooksFn = [];\n    var scroller = this.scroll.scroller;\n    var scrollBehaviorY = scroller.scrollBehaviorY;\n    this.currentMinScrollY = this.cachedOriginanMinScrollY = scrollBehaviorY.minScrollPos;\n    this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.contentChanged, function () {\n      _this.finishPullDown();\n    });\n    this.registerHooks(scrollBehaviorY.hooks, scrollBehaviorY.hooks.eventTypes.computeBoundary, function (boundary) {\n      // content is smaller than wrapper\n      if (boundary.maxScrollPos > 0) {\n        // allow scrolling when content is not full of wrapper\n        boundary.maxScrollPos = -1;\n      }\n\n      boundary.minScrollPos = _this.currentMinScrollY;\n    }); // integrate with mousewheel\n\n    if (this.hasMouseWheelPlugin()) {\n      this.registerHooks(this.scroll, this.scroll.eventTypes.alterOptions, function (mouseWheelOptions) {\n        var SANE_DISCRETE_TIME = 300;\n        var SANE_EASE_TIME = 350;\n        mouseWheelOptions.discreteTime = SANE_DISCRETE_TIME; // easeTime > discreteTime ensure goInto checkPullDown function\n\n        mouseWheelOptions.easeTime = SANE_EASE_TIME;\n      });\n      this.registerHooks(this.scroll, this.scroll.eventTypes.mousewheelEnd, function () {\n        // mouseWheel need trigger checkPullDown manually\n        scroller.hooks.trigger(scroller.hooks.eventTypes.end);\n      });\n    }\n  };\n\n  PullDown.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  PullDown.prototype.hasMouseWheelPlugin = function () {\n    return !!this.scroll.eventTypes.alterOptions;\n  };\n\n  PullDown.prototype.watch = function () {\n    var scroller = this.scroll.scroller;\n    this.watching = true;\n    this.registerHooks(scroller.hooks, scroller.hooks.eventTypes.end, this.checkPullDown);\n    this.registerHooks(this.scroll, this.scroll.eventTypes.scrollStart, this.resetStateBeforeScrollStart);\n    this.registerHooks(this.scroll, this.scroll.eventTypes.scroll, this.checkLocationOfThresholdBoundary);\n\n    if (this.hasMouseWheelPlugin()) {\n      this.registerHooks(this.scroll, this.scroll.eventTypes.mousewheelStart, this.resetStateBeforeScrollStart);\n    }\n  };\n\n  PullDown.prototype.resetStateBeforeScrollStart = function () {\n    // current fetching pulldownRefresh has ended\n    if (!this.isFetchingStatus()) {\n      this.setPulling(1\n      /* MOVING */\n      );\n      this.setThresholdBoundary(0\n      /* DEFAULT */\n      );\n    }\n  };\n\n  PullDown.prototype.checkLocationOfThresholdBoundary = function () {\n    // pulldownRefresh is in the phase of Moving\n    if (this.pulling === 1\n    /* MOVING */\n    ) {\n      var scroll_1 = this.scroll; // enter threshold boundary\n\n      var enteredThresholdBoundary = this.thresholdBoundary !== 1\n      /* INSIDE */\n      && this.locateInsideThresholdBoundary(); // leave threshold boundary\n\n      var leftThresholdBoundary = this.thresholdBoundary !== 2\n      /* OUTSIDE */\n      && !this.locateInsideThresholdBoundary();\n\n      if (enteredThresholdBoundary) {\n        this.setThresholdBoundary(1\n        /* INSIDE */\n        );\n        scroll_1.trigger(ENTER_THRESHOLD_EVENT);\n      }\n\n      if (leftThresholdBoundary) {\n        this.setThresholdBoundary(2\n        /* OUTSIDE */\n        );\n        scroll_1.trigger(LEAVE_THRESHOLD_EVENT);\n      }\n    }\n  };\n\n  PullDown.prototype.locateInsideThresholdBoundary = function () {\n    return this.scroll.y <= this.options.threshold;\n  };\n\n  PullDown.prototype.unwatch = function () {\n    var scroll = this.scroll;\n    var scroller = scroll.scroller;\n    this.watching = false;\n    scroller.hooks.off(scroller.hooks.eventTypes.end, this.checkPullDown);\n    scroll.off(scroll.eventTypes.scrollStart, this.resetStateBeforeScrollStart);\n    scroll.off(scroll.eventTypes.scroll, this.checkLocationOfThresholdBoundary);\n\n    if (this.hasMouseWheelPlugin()) {\n      scroll.off(scroll.eventTypes.mousewheelStart, this.resetStateBeforeScrollStart);\n    }\n  };\n\n  PullDown.prototype.checkPullDown = function () {\n    var _a = this.options,\n        threshold = _a.threshold,\n        stop = _a.stop; // check if a real pull down action\n\n    if (this.scroll.y < threshold) {\n      return false;\n    }\n\n    if (this.pulling === 1\n    /* MOVING */\n    ) {\n      this.modifyBehaviorYBoundary(stop);\n      this.setPulling(2\n      /* FETCHING */\n      );\n      this.scroll.trigger(PULLING_DOWN_EVENT);\n    }\n\n    this.scroll.scrollTo(this.scroll.x, stop, this.scroll.options.bounceTime, ease.bounce);\n    return this.isFetchingStatus();\n  };\n\n  PullDown.prototype.isFetchingStatus = function () {\n    return this.pulling === 2\n    /* FETCHING */\n    ;\n  };\n\n  PullDown.prototype.modifyBehaviorYBoundary = function (stopDistance) {\n    var scrollBehaviorY = this.scroll.scroller.scrollBehaviorY; // manually modify minScrollPos for a hang animation\n    // to prevent from resetPosition\n\n    this.cachedOriginanMinScrollY = scrollBehaviorY.minScrollPos;\n    this.currentMinScrollY = stopDistance;\n    scrollBehaviorY.computeBoundary();\n  };\n\n  PullDown.prototype.finishPullDown = function () {\n    if (this.isFetchingStatus()) {\n      var scrollBehaviorY = this.scroll.scroller.scrollBehaviorY; // restore minScrollY since the hang animation has ended\n\n      this.currentMinScrollY = this.cachedOriginanMinScrollY;\n      scrollBehaviorY.computeBoundary();\n      this.setPulling(0\n      /* DEFAULT */\n      );\n      this.scroll.resetPosition(this.scroll.options.bounceTime, ease.bounce);\n    }\n  }; // allow 'true' type is compat for beta version implements\n\n\n  PullDown.prototype.openPullDown = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.handleOptions(config);\n\n    if (!this.watching) {\n      this.watch();\n    }\n  };\n\n  PullDown.prototype.closePullDown = function () {\n    this.unwatch();\n  };\n\n  PullDown.prototype.autoPullDownRefresh = function () {\n    var _a = this.options,\n        threshold = _a.threshold,\n        stop = _a.stop;\n\n    if (this.isFetchingStatus() || !this.watching) {\n      return;\n    }\n\n    this.modifyBehaviorYBoundary(stop);\n    this.scroll.trigger(this.scroll.eventTypes.scrollStart);\n    this.scroll.scrollTo(this.scroll.x, threshold);\n    this.setPulling(2\n    /* FETCHING */\n    );\n    this.scroll.trigger(PULLING_DOWN_EVENT);\n    this.scroll.scrollTo(this.scroll.x, stop, this.scroll.options.bounceTime, ease.bounce);\n  };\n\n  PullDown.pluginName = 'pullDownRefresh';\n  return PullDown;\n}();\n\nvar sourcePrefix$5 = 'plugins.pullUpLoad';\nvar propertiesMap$5 = [{\n  key: 'finishPullUp',\n  name: 'finishPullUp'\n}, {\n  key: 'openPullUp',\n  name: 'openPullUp'\n}, {\n  key: 'closePullUp',\n  name: 'closePullUp'\n}, {\n  key: 'autoPullUpLoad',\n  name: 'autoPullUpLoad'\n}];\nvar propertiesConfig$5 = propertiesMap$5.map(function (item) {\n  return {\n    key: item.key,\n    sourceKey: sourcePrefix$5 + \".\" + item.name\n  };\n});\nvar PULL_UP_HOOKS_NAME = 'pullingUp';\n\nvar PullUp =\n/** @class */\nfunction () {\n  function PullUp(scroll) {\n    this.scroll = scroll;\n    this.pulling = false;\n    this.watching = false;\n    this.init();\n  }\n\n  PullUp.prototype.init = function () {\n    this.handleBScroll();\n    this.handleOptions(this.scroll.options.pullUpLoad);\n    this.handleHooks();\n    this.watch();\n  };\n\n  PullUp.prototype.handleBScroll = function () {\n    this.scroll.registerType([PULL_UP_HOOKS_NAME]);\n    this.scroll.proxy(propertiesConfig$5);\n  };\n\n  PullUp.prototype.handleOptions = function (userOptions) {\n    if (userOptions === void 0) {\n      userOptions = {};\n    }\n\n    userOptions = userOptions === true ? {} : userOptions;\n    var defaultOptions = {\n      threshold: 0\n    };\n    this.options = extend(defaultOptions, userOptions);\n    this.scroll.options.probeType = 3\n    /* Realtime */\n    ;\n  };\n\n  PullUp.prototype.handleHooks = function () {\n    var _this = this;\n\n    this.hooksFn = [];\n    var scrollBehaviorY = this.scroll.scroller.scrollBehaviorY;\n    this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.contentChanged, function () {\n      _this.finishPullUp();\n    });\n    this.registerHooks(scrollBehaviorY.hooks, scrollBehaviorY.hooks.eventTypes.computeBoundary, function (boundary) {\n      // content is smaller than wrapper\n      if (boundary.maxScrollPos > 0) {\n        // allow scrolling when content is not full of wrapper\n        boundary.maxScrollPos = -1;\n      }\n    });\n  };\n\n  PullUp.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  PullUp.prototype.watch = function () {\n    if (this.watching) {\n      return;\n    }\n\n    this.watching = true;\n    this.registerHooks(this.scroll, this.scroll.eventTypes.scroll, this.checkPullUp);\n  };\n\n  PullUp.prototype.unwatch = function () {\n    this.watching = false;\n    this.scroll.off(this.scroll.eventTypes.scroll, this.checkPullUp);\n  };\n\n  PullUp.prototype.checkPullUp = function (pos) {\n    var _this = this;\n\n    var threshold = this.options.threshold;\n\n    if (this.scroll.movingDirectionY === 1\n    /* Positive */\n    && pos.y <= this.scroll.maxScrollY + threshold) {\n      this.pulling = true; // must reset pulling after scrollEnd\n\n      this.scroll.once(this.scroll.eventTypes.scrollEnd, function () {\n        _this.pulling = false;\n      });\n      this.unwatch();\n      this.scroll.trigger(PULL_UP_HOOKS_NAME);\n    }\n  };\n\n  PullUp.prototype.finishPullUp = function () {\n    var _this = this; // reset Direction, fix #936\n\n\n    this.scroll.scroller.scrollBehaviorY.setMovingDirection(0\n    /* Default */\n    );\n\n    if (this.pulling) {\n      this.scroll.once(this.scroll.eventTypes.scrollEnd, function () {\n        _this.watch();\n      });\n    } else {\n      this.watch();\n    }\n  }; // allow 'true' type is compat for beta version implements\n\n\n  PullUp.prototype.openPullUp = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    this.handleOptions(config);\n    this.watch();\n  };\n\n  PullUp.prototype.closePullUp = function () {\n    this.unwatch();\n  };\n\n  PullUp.prototype.autoPullUpLoad = function () {\n    var threshold = this.options.threshold;\n    var scrollBehaviorY = this.scroll.scroller.scrollBehaviorY;\n\n    if (this.pulling || !this.watching) {\n      return;\n    } // simulate a pullUp action\n\n\n    var NEGATIVE_VALUE = -1;\n    var outOfBoundaryPos = scrollBehaviorY.maxScrollPos + threshold + NEGATIVE_VALUE;\n    this.scroll.scroller.scrollBehaviorY.setMovingDirection(NEGATIVE_VALUE);\n    this.scroll.scrollTo(this.scroll.x, outOfBoundaryPos, this.scroll.options.bounceTime);\n  };\n\n  PullUp.pluginName = 'pullUpLoad';\n  return PullUp;\n}();\n\nvar EventHandler =\n/** @class */\nfunction () {\n  function EventHandler(indicator, options) {\n    this.indicator = indicator;\n    this.options = options;\n    this.hooks = new EventEmitter(['touchStart', 'touchMove', 'touchEnd']);\n    this.registerEvents();\n  }\n\n  EventHandler.prototype.registerEvents = function () {\n    var _a = this.options,\n        disableMouse = _a.disableMouse,\n        disableTouch = _a.disableTouch;\n    var startEvents = [];\n    var moveEvents = [];\n    var endEvents = [];\n\n    if (!disableMouse) {\n      startEvents.push({\n        name: 'mousedown',\n        handler: this.start.bind(this)\n      });\n      moveEvents.push({\n        name: 'mousemove',\n        handler: this.move.bind(this)\n      });\n      endEvents.push({\n        name: 'mouseup',\n        handler: this.end.bind(this)\n      });\n    }\n\n    if (!disableTouch) {\n      startEvents.push({\n        name: 'touchstart',\n        handler: this.start.bind(this)\n      });\n      moveEvents.push({\n        name: 'touchmove',\n        handler: this.move.bind(this)\n      });\n      endEvents.push({\n        name: 'touchend',\n        handler: this.end.bind(this)\n      }, {\n        name: 'touchcancel',\n        handler: this.end.bind(this)\n      });\n    }\n\n    this.startEventRegister = new EventRegister(this.indicator.indicatorEl, startEvents);\n    this.moveEventRegister = new EventRegister(window, moveEvents);\n    this.endEventRegister = new EventRegister(window, endEvents);\n  };\n\n  EventHandler.prototype.BScrollIsDisabled = function () {\n    return !this.indicator.scroll.enabled;\n  };\n\n  EventHandler.prototype.start = function (e) {\n    if (this.BScrollIsDisabled()) {\n      return;\n    }\n\n    var point = e.touches ? e.touches[0] : e;\n    maybePrevent(e);\n    e.stopPropagation();\n    this.initiated = true;\n    this.lastPoint = point[this.indicator.keysMap.point];\n    this.hooks.trigger(this.hooks.eventTypes.touchStart);\n  };\n\n  EventHandler.prototype.move = function (e) {\n    if (!this.initiated) {\n      return;\n    }\n\n    var point = e.touches ? e.touches[0] : e;\n    var pointPos = point[this.indicator.keysMap.point];\n    maybePrevent(e);\n    e.stopPropagation();\n    var delta = pointPos - this.lastPoint;\n    this.lastPoint = pointPos;\n    this.hooks.trigger(this.hooks.eventTypes.touchMove, delta);\n  };\n\n  EventHandler.prototype.end = function (e) {\n    if (!this.initiated) {\n      return;\n    }\n\n    this.initiated = false;\n    maybePrevent(e);\n    e.stopPropagation();\n    this.hooks.trigger(this.hooks.eventTypes.touchEnd);\n  };\n\n  EventHandler.prototype.destroy = function () {\n    this.startEventRegister.destroy();\n    this.moveEventRegister.destroy();\n    this.endEventRegister.destroy();\n  };\n\n  return EventHandler;\n}();\n\nvar Indicator$1 =\n/** @class */\nfunction () {\n  function Indicator(scroll, options) {\n    this.scroll = scroll;\n    this.options = options;\n    this.hooksFn = [];\n    this.wrapper = options.wrapper;\n    this.direction = options.direction;\n    this.indicatorEl = this.wrapper.children[0];\n    this.keysMap = this.getKeysMap();\n    this.handleFade();\n    this.handleHooks();\n  }\n\n  Indicator.prototype.handleFade = function () {\n    if (this.options.fade) {\n      this.wrapper.style.opacity = '0';\n    }\n  };\n\n  Indicator.prototype.handleHooks = function () {\n    var _this = this;\n\n    var _a = this.options,\n        fade = _a.fade,\n        interactive = _a.interactive,\n        scrollbarTrackClickable = _a.scrollbarTrackClickable;\n    var scroll = this.scroll;\n    var scrollHooks = scroll.hooks;\n    var translaterHooks = scroll.scroller.translater.hooks;\n    var animaterHooks = scroll.scroller.animater.hooks;\n    this.registerHooks(scrollHooks, scrollHooks.eventTypes.refresh, this.refresh);\n    this.registerHooks(translaterHooks, translaterHooks.eventTypes.translate, function (pos) {\n      var hasScrollKey = _this.keysMap.hasScroll;\n\n      if (_this.scroll[hasScrollKey]) {\n        _this.updatePosition(pos);\n      }\n    });\n    this.registerHooks(animaterHooks, animaterHooks.eventTypes.time, this.transitionTime);\n    this.registerHooks(animaterHooks, animaterHooks.eventTypes.timeFunction, this.transitionTimingFunction);\n\n    if (fade) {\n      this.registerHooks(scroll, scroll.eventTypes.scrollEnd, function () {\n        _this.fade();\n      });\n      this.registerHooks(scroll, scroll.eventTypes.scrollStart, function () {\n        _this.fade(true);\n      }); // for mousewheel event\n\n      if (scroll.eventTypes.mousewheelStart && scroll.eventTypes.mousewheelEnd) {\n        this.registerHooks(scroll, scroll.eventTypes.mousewheelStart, function () {\n          _this.fade(true);\n        });\n        this.registerHooks(scroll, scroll.eventTypes.mousewheelMove, function () {\n          _this.fade(true);\n        });\n        this.registerHooks(scroll, scroll.eventTypes.mousewheelEnd, function () {\n          _this.fade();\n        });\n      }\n    }\n\n    if (interactive) {\n      var _b = this.scroll.options,\n          disableMouse = _b.disableMouse,\n          disableTouch = _b.disableTouch;\n      this.eventHandler = new EventHandler(this, {\n        disableMouse: disableMouse,\n        disableTouch: disableTouch\n      });\n      var eventHandlerHooks = this.eventHandler.hooks;\n      this.registerHooks(eventHandlerHooks, eventHandlerHooks.eventTypes.touchStart, this.startHandler);\n      this.registerHooks(eventHandlerHooks, eventHandlerHooks.eventTypes.touchMove, this.moveHandler);\n      this.registerHooks(eventHandlerHooks, eventHandlerHooks.eventTypes.touchEnd, this.endHandler);\n    }\n\n    if (scrollbarTrackClickable) {\n      this.bindClick();\n    }\n  };\n\n  Indicator.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  Indicator.prototype.bindClick = function () {\n    var wrapper = this.wrapper;\n    this.clickEventRegister = new EventRegister(wrapper, [{\n      name: 'click',\n      handler: this.handleClick.bind(this)\n    }]);\n  };\n\n  Indicator.prototype.handleClick = function (e) {\n    var newPos = this.calculateclickOffsetPos(e);\n    var _a = this.scroll,\n        x = _a.x,\n        y = _a.y;\n    x = this.direction === \"horizontal\"\n    /* Horizontal */\n    ? newPos : x;\n    y = this.direction === \"vertical\"\n    /* Vertical */\n    ? newPos : y;\n    this.scroll.scrollTo(x, y, this.options.scrollbarTrackOffsetTime);\n  };\n\n  Indicator.prototype.calculateclickOffsetPos = function (e) {\n    var _a = this.keysMap,\n        poinKey = _a.point,\n        domRectKey = _a.domRect;\n    var scrollbarTrackOffsetType = this.options.scrollbarTrackOffsetType;\n    var clickPointOffset = e[poinKey] - this.wrapperRect[domRectKey];\n    var scrollToWhere = clickPointOffset < this.currentPos ? -1\n    /* Up */\n    : 1\n    /* Down */\n    ;\n    var delta = 0;\n    var currentPos = this.currentPos;\n\n    if (scrollbarTrackOffsetType === \"step\"\n    /* Step */\n    ) {\n      delta = this.scrollInfo.baseSize * scrollToWhere;\n    } else {\n      delta = 0;\n      currentPos = clickPointOffset;\n    }\n\n    return this.newPos(currentPos, delta, this.scrollInfo);\n  };\n\n  Indicator.prototype.getKeysMap = function () {\n    if (this.direction === \"vertical\"\n    /* Vertical */\n    ) {\n      return {\n        hasScroll: 'hasVerticalScroll',\n        size: 'height',\n        wrapperSize: 'clientHeight',\n        scrollerSize: 'scrollerHeight',\n        maxScrollPos: 'maxScrollY',\n        pos: 'y',\n        point: 'pageY',\n        translateProperty: 'translateY',\n        domRect: 'top'\n      };\n    }\n\n    return {\n      hasScroll: 'hasHorizontalScroll',\n      size: 'width',\n      wrapperSize: 'clientWidth',\n      scrollerSize: 'scrollerWidth',\n      maxScrollPos: 'maxScrollX',\n      pos: 'x',\n      point: 'pageX',\n      translateProperty: 'translateX',\n      domRect: 'left'\n    };\n  };\n\n  Indicator.prototype.fade = function (visible) {\n    var _a = this.options,\n        fadeInTime = _a.fadeInTime,\n        fadeOutTime = _a.fadeOutTime;\n    var time = visible ? fadeInTime : fadeOutTime;\n    var wrapper = this.wrapper;\n    wrapper.style[style.transitionDuration] = time + 'ms';\n    wrapper.style.opacity = visible ? '1' : '0';\n  };\n\n  Indicator.prototype.refresh = function () {\n    var hasScrollKey = this.keysMap.hasScroll;\n    var scroll = this.scroll;\n    var x = scroll.x,\n        y = scroll.y;\n    this.wrapperRect = this.wrapper.getBoundingClientRect();\n\n    if (this.canScroll(scroll[hasScrollKey])) {\n      var _a = this.keysMap,\n          wrapperSizeKey = _a.wrapperSize,\n          scrollerSizeKey = _a.scrollerSize,\n          maxScrollPosKey = _a.maxScrollPos;\n      this.scrollInfo = this.refreshScrollInfo(this.wrapper[wrapperSizeKey], scroll[scrollerSizeKey], scroll[maxScrollPosKey], this.indicatorEl[wrapperSizeKey]);\n      this.updatePosition({\n        x: x,\n        y: y\n      });\n    }\n  };\n\n  Indicator.prototype.transitionTime = function (time) {\n    if (time === void 0) {\n      time = 0;\n    }\n\n    this.indicatorEl.style[style.transitionDuration] = time + 'ms';\n  };\n\n  Indicator.prototype.transitionTimingFunction = function (easing) {\n    this.indicatorEl.style[style.transitionTimingFunction] = easing;\n  };\n\n  Indicator.prototype.canScroll = function (hasScroll) {\n    this.wrapper.style.display = hasScroll ? 'block' : 'none';\n    return hasScroll;\n  };\n\n  Indicator.prototype.refreshScrollInfo = function (wrapperSize, scrollerSize, maxScrollPos, indicatorElSize) {\n    var baseSize = Math.max(Math.round(wrapperSize * wrapperSize / (scrollerSize || wrapperSize || 1)), this.options.minSize);\n\n    if (this.options.isCustom) {\n      baseSize = indicatorElSize;\n    }\n\n    var maxIndicatorScrollPos = wrapperSize - baseSize; // sizeRatio is negative\n\n    var sizeRatio = maxIndicatorScrollPos / maxScrollPos;\n    return {\n      baseSize: baseSize,\n      maxScrollPos: maxIndicatorScrollPos,\n      minScrollPos: 0,\n      sizeRatio: sizeRatio\n    };\n  };\n\n  Indicator.prototype.updatePosition = function (point) {\n    var _a = this.caculatePosAndSize(point, this.scrollInfo),\n        pos = _a.pos,\n        size = _a.size;\n\n    this.refreshStyle(size, pos);\n    this.currentPos = pos;\n  };\n\n  Indicator.prototype.caculatePosAndSize = function (point, scrollInfo) {\n    var posKey = this.keysMap.pos;\n    var sizeRatio = scrollInfo.sizeRatio,\n        baseSize = scrollInfo.baseSize,\n        maxScrollPos = scrollInfo.maxScrollPos,\n        minScrollPos = scrollInfo.minScrollPos;\n    var minSize = this.options.minSize;\n    var pos = Math.round(sizeRatio * point[posKey]);\n    var size; // when out of boundary, slow down size reduction\n\n    if (pos < minScrollPos) {\n      size = Math.max(baseSize + pos * 3, minSize);\n      pos = minScrollPos;\n    } else if (pos > maxScrollPos) {\n      size = Math.max(baseSize - (pos - maxScrollPos) * 3, minSize);\n      pos = maxScrollPos + baseSize - size;\n    } else {\n      size = baseSize;\n    }\n\n    return {\n      pos: pos,\n      size: size\n    };\n  };\n\n  Indicator.prototype.refreshStyle = function (size, pos) {\n    var _a = this.keysMap,\n        translatePropertyKey = _a.translateProperty,\n        sizeKey = _a.size;\n    var translateZ = this.scroll.options.translateZ;\n    this.indicatorEl.style[sizeKey] = size + \"px\";\n    this.indicatorEl.style[style.transform] = translatePropertyKey + \"(\" + pos + \"px)\" + translateZ;\n  };\n\n  Indicator.prototype.startHandler = function () {\n    this.moved = false;\n    this.startTime = getNow();\n    this.transitionTime();\n    this.scroll.scroller.hooks.trigger(this.scroll.scroller.hooks.eventTypes.beforeScrollStart);\n  };\n\n  Indicator.prototype.moveHandler = function (delta) {\n    if (!this.moved && !this.indicatorNotMoved(delta)) {\n      this.moved = true;\n      this.scroll.scroller.hooks.trigger(this.scroll.scroller.hooks.eventTypes.scrollStart);\n    }\n\n    if (this.moved) {\n      var newPos = this.newPos(this.currentPos, delta, this.scrollInfo);\n      this.syncBScroll(newPos);\n    }\n  };\n\n  Indicator.prototype.endHandler = function () {\n    if (this.moved) {\n      var _a = this.scroll,\n          x = _a.x,\n          y = _a.y;\n      this.scroll.scroller.hooks.trigger(this.scroll.scroller.hooks.eventTypes.scrollEnd, {\n        x: x,\n        y: y\n      });\n    }\n  };\n\n  Indicator.prototype.indicatorNotMoved = function (delta) {\n    var currentPos = this.currentPos;\n    var _a = this.scrollInfo,\n        maxScrollPos = _a.maxScrollPos,\n        minScrollPos = _a.minScrollPos;\n    var notMoved = currentPos === minScrollPos && delta <= 0 || currentPos === maxScrollPos && delta >= 0;\n    return notMoved;\n  };\n\n  Indicator.prototype.syncBScroll = function (newPos) {\n    var timestamp = getNow();\n    var _a = this.scroll,\n        x = _a.x,\n        y = _a.y,\n        options = _a.options,\n        scroller = _a.scroller,\n        maxScrollY = _a.maxScrollY,\n        minScrollY = _a.minScrollY,\n        maxScrollX = _a.maxScrollX,\n        minScrollX = _a.minScrollX;\n    var probeType = options.probeType,\n        momentumLimitTime = options.momentumLimitTime;\n    var position = {\n      x: x,\n      y: y\n    };\n\n    if (this.direction === \"vertical\"\n    /* Vertical */\n    ) {\n      position.y = between(newPos, maxScrollY, minScrollY);\n    } else {\n      position.x = between(newPos, maxScrollX, minScrollX);\n    }\n\n    scroller.translater.translate(position); // dispatch scroll in interval time\n\n    if (timestamp - this.startTime > momentumLimitTime) {\n      this.startTime = timestamp;\n\n      if (probeType === 1\n      /* Throttle */\n      ) {\n        scroller.hooks.trigger(scroller.hooks.eventTypes.scroll, position);\n      }\n    } // dispatch scroll all the time\n\n\n    if (probeType > 1\n    /* Throttle */\n    ) {\n      scroller.hooks.trigger(scroller.hooks.eventTypes.scroll, position);\n    }\n  };\n\n  Indicator.prototype.newPos = function (currentPos, delta, scrollInfo) {\n    var maxScrollPos = scrollInfo.maxScrollPos,\n        sizeRatio = scrollInfo.sizeRatio,\n        minScrollPos = scrollInfo.minScrollPos;\n    var newPos = currentPos + delta;\n    newPos = between(newPos, minScrollPos, maxScrollPos);\n    return Math.round(newPos / sizeRatio);\n  };\n\n  Indicator.prototype.destroy = function () {\n    var _a = this.options,\n        interactive = _a.interactive,\n        scrollbarTrackClickable = _a.scrollbarTrackClickable,\n        isCustom = _a.isCustom;\n\n    if (interactive) {\n      this.eventHandler.destroy();\n    }\n\n    if (scrollbarTrackClickable) {\n      this.clickEventRegister.destroy();\n    }\n\n    if (!isCustom) {\n      this.wrapper.parentNode.removeChild(this.wrapper);\n    }\n\n    this.hooksFn.forEach(function (item) {\n      var hooks = item[0];\n      var hooksName = item[1];\n      var handlerFn = item[2];\n      hooks.off(hooksName, handlerFn);\n    });\n    this.hooksFn.length = 0;\n  };\n\n  return Indicator;\n}();\n\nvar ScrollBar =\n/** @class */\nfunction () {\n  function ScrollBar(scroll) {\n    this.scroll = scroll;\n    this.handleOptions();\n    this.createIndicators();\n    this.handleHooks();\n  }\n\n  ScrollBar.prototype.handleHooks = function () {\n    var _this = this;\n\n    var scroll = this.scroll;\n    scroll.hooks.on(scroll.hooks.eventTypes.destroy, function () {\n      for (var _i = 0, _a = _this.indicators; _i < _a.length; _i++) {\n        var indicator = _a[_i];\n        indicator.destroy();\n      }\n    });\n  };\n\n  ScrollBar.prototype.handleOptions = function () {\n    var userOptions = this.scroll.options.scrollbar === true ? {} : this.scroll.options.scrollbar;\n    var defaultOptions = {\n      fade: true,\n      fadeInTime: 250,\n      fadeOutTime: 500,\n      interactive: false,\n      customElements: [],\n      minSize: 8,\n      scrollbarTrackClickable: false,\n      scrollbarTrackOffsetType: \"step\"\n      /* Step */\n      ,\n      scrollbarTrackOffsetTime: 300\n    };\n    this.options = extend(defaultOptions, userOptions);\n  };\n\n  ScrollBar.prototype.createIndicators = function () {\n    var indicatorOptions;\n    var scroll = this.scroll;\n    var indicators = [];\n    var scrollDirectionConfigKeys = ['scrollX', 'scrollY'];\n    var indicatorDirections = [\"horizontal\"\n    /* Horizontal */\n    , \"vertical\"\n    /* Vertical */\n    ];\n    var customScrollbarEls = this.options.customElements;\n\n    for (var i = 0; i < scrollDirectionConfigKeys.length; i++) {\n      var key = scrollDirectionConfigKeys[i]; // wanna scroll in specified direction\n\n      if (scroll.options[key]) {\n        var customElement = customScrollbarEls.shift();\n        var direction = indicatorDirections[i];\n        var isCustom = false;\n        var scrollbarWrapper = customElement ? customElement : this.createScrollbarElement(direction); // internal scrollbar\n\n        if (scrollbarWrapper !== customElement) {\n          scroll.wrapper.appendChild(scrollbarWrapper);\n        } else {\n          // custom scrollbar passed by users\n          isCustom = true;\n        }\n\n        indicatorOptions = __assign(__assign({\n          wrapper: scrollbarWrapper,\n          direction: direction\n        }, this.options), {\n          isCustom: isCustom\n        });\n        indicators.push(new Indicator$1(scroll, indicatorOptions));\n      }\n    }\n\n    this.indicators = indicators;\n  };\n\n  ScrollBar.prototype.createScrollbarElement = function (direction, scrollbarTrackClickable) {\n    if (scrollbarTrackClickable === void 0) {\n      scrollbarTrackClickable = this.options.scrollbarTrackClickable;\n    }\n\n    var scrollbarWrapperEl = document.createElement('div');\n    var scrollbarIndicatorEl = document.createElement('div');\n    scrollbarWrapperEl.style.cssText = 'position:absolute;z-index:9999;overflow:hidden;';\n    scrollbarIndicatorEl.style.cssText = 'box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px;';\n    scrollbarIndicatorEl.className = 'bscroll-indicator';\n\n    if (direction === \"horizontal\"\n    /* Horizontal */\n    ) {\n      scrollbarWrapperEl.style.cssText += 'height:7px;left:2px;right:2px;bottom:0;';\n      scrollbarIndicatorEl.style.height = '100%';\n      scrollbarWrapperEl.className = 'bscroll-horizontal-scrollbar';\n    } else {\n      scrollbarWrapperEl.style.cssText += 'width:7px;bottom:2px;top:2px;right:1px;';\n      scrollbarIndicatorEl.style.width = '100%';\n      scrollbarWrapperEl.className = 'bscroll-vertical-scrollbar';\n    }\n\n    if (!scrollbarTrackClickable) {\n      scrollbarWrapperEl.style.cssText += 'pointer-events:none;';\n    }\n\n    scrollbarWrapperEl.appendChild(scrollbarIndicatorEl);\n    return scrollbarWrapperEl;\n  };\n\n  ScrollBar.pluginName = 'scrollbar';\n  return ScrollBar;\n}();\n\nvar PagesMatrix =\n/** @class */\nfunction () {\n  function PagesMatrix(scroll) {\n    this.scroll = scroll;\n    this.init();\n  }\n\n  PagesMatrix.prototype.init = function () {\n    var scroller = this.scroll.scroller;\n    var scrollBehaviorX = scroller.scrollBehaviorX,\n        scrollBehaviorY = scroller.scrollBehaviorY;\n    this.wrapperWidth = scrollBehaviorX.wrapperSize;\n    this.wrapperHeight = scrollBehaviorY.wrapperSize;\n    this.scrollerHeight = scrollBehaviorY.contentSize;\n    this.scrollerWidth = scrollBehaviorX.contentSize;\n    this.pages = this.buildPagesMatrix(this.wrapperWidth, this.wrapperHeight);\n    this.pageLengthOfX = this.pages ? this.pages.length : 0;\n    this.pageLengthOfY = this.pages && this.pages[0] ? this.pages[0].length : 0;\n  };\n\n  PagesMatrix.prototype.getPageStats = function (pageX, pageY) {\n    return this.pages[pageX][pageY];\n  };\n\n  PagesMatrix.prototype.getNearestPageIndex = function (x, y) {\n    var pageX = 0;\n    var pageY = 0;\n    var l = this.pages.length;\n\n    for (; pageX < l - 1; pageX++) {\n      if (x >= this.pages[pageX][0].cx) {\n        break;\n      }\n    }\n\n    l = this.pages[pageX].length;\n\n    for (; pageY < l - 1; pageY++) {\n      if (y >= this.pages[0][pageY].cy) {\n        break;\n      }\n    }\n\n    return {\n      pageX: pageX,\n      pageY: pageY\n    };\n  }; // (n x 1) matrix for horizontal scroll or\n  // (1 * n) matrix for vertical scroll\n\n\n  PagesMatrix.prototype.buildPagesMatrix = function (stepX, stepY) {\n    var pages = [];\n    var x = 0;\n    var y;\n    var cx;\n    var cy;\n    var i = 0;\n    var l;\n    var maxScrollPosX = this.scroll.scroller.scrollBehaviorX.maxScrollPos;\n    var maxScrollPosY = this.scroll.scroller.scrollBehaviorY.maxScrollPos;\n    cx = Math.round(stepX / 2);\n    cy = Math.round(stepY / 2);\n\n    while (x > -this.scrollerWidth) {\n      pages[i] = [];\n      l = 0;\n      y = 0;\n\n      while (y > -this.scrollerHeight) {\n        pages[i][l] = {\n          x: Math.max(x, maxScrollPosX),\n          y: Math.max(y, maxScrollPosY),\n          width: stepX,\n          height: stepY,\n          cx: x - cx,\n          cy: y - cy\n        };\n        y -= stepY;\n        l++;\n      }\n\n      x -= stepX;\n      i++;\n    }\n\n    return pages;\n  };\n\n  return PagesMatrix;\n}();\n\nvar BASE_PAGE = {\n  pageX: 0,\n  pageY: 0,\n  x: 0,\n  y: 0\n};\n\nvar SlidePages =\n/** @class */\nfunction () {\n  function SlidePages(scroll, slideOptions) {\n    this.scroll = scroll;\n    this.slideOptions = slideOptions;\n    this.slideX = false;\n    this.slideY = false;\n    this.currentPage = extend({}, BASE_PAGE);\n  }\n\n  SlidePages.prototype.refresh = function () {\n    this.pagesMatrix = new PagesMatrix(this.scroll);\n    this.checkSlideLoop();\n    this.currentPage = this.getAdjustedCurrentPage();\n  };\n\n  SlidePages.prototype.getAdjustedCurrentPage = function () {\n    var _a = this.currentPage,\n        pageX = _a.pageX,\n        pageY = _a.pageY; // page index should be handled\n    // because page counts may reduce\n\n    pageX = Math.min(pageX, this.pagesMatrix.pageLengthOfX - 1);\n    pageY = Math.min(pageY, this.pagesMatrix.pageLengthOfY - 1); // loop scene should also be respected\n    // because clonedNode will cause pageLength increasing\n\n    if (this.loopX) {\n      pageX = Math.min(pageX, this.pagesMatrix.pageLengthOfX - 2);\n    }\n\n    if (this.loopY) {\n      pageY = Math.min(pageY, this.pagesMatrix.pageLengthOfY - 2);\n    }\n\n    var _b = this.pagesMatrix.getPageStats(pageX, pageY),\n        x = _b.x,\n        y = _b.y;\n\n    return {\n      pageX: pageX,\n      pageY: pageY,\n      x: x,\n      y: y\n    };\n  };\n\n  SlidePages.prototype.setCurrentPage = function (newPage) {\n    this.currentPage = newPage;\n  };\n\n  SlidePages.prototype.getInternalPage = function (pageX, pageY) {\n    if (pageX >= this.pagesMatrix.pageLengthOfX) {\n      pageX = this.pagesMatrix.pageLengthOfX - 1;\n    } else if (pageX < 0) {\n      pageX = 0;\n    }\n\n    if (pageY >= this.pagesMatrix.pageLengthOfY) {\n      pageY = this.pagesMatrix.pageLengthOfY - 1;\n    } else if (pageY < 0) {\n      pageY = 0;\n    }\n\n    var _a = this.pagesMatrix.getPageStats(pageX, pageY),\n        x = _a.x,\n        y = _a.y;\n\n    return {\n      pageX: pageX,\n      pageY: pageY,\n      x: x,\n      y: y\n    };\n  };\n\n  SlidePages.prototype.getInitialPage = function (showFirstPage, firstInitialised) {\n    if (showFirstPage === void 0) {\n      showFirstPage = false;\n    }\n\n    if (firstInitialised === void 0) {\n      firstInitialised = false;\n    }\n\n    var _a = this.slideOptions,\n        startPageXIndex = _a.startPageXIndex,\n        startPageYIndex = _a.startPageYIndex;\n    var firstPageX = this.loopX ? 1 : 0;\n    var firstPageY = this.loopY ? 1 : 0;\n    var pageX = showFirstPage ? firstPageX : this.currentPage.pageX;\n    var pageY = showFirstPage ? firstPageY : this.currentPage.pageY;\n\n    if (firstInitialised) {\n      pageX = this.loopX ? startPageXIndex + 1 : startPageXIndex;\n      pageY = this.loopY ? startPageYIndex + 1 : startPageYIndex;\n    } else {\n      pageX = showFirstPage ? firstPageX : this.currentPage.pageX;\n      pageY = showFirstPage ? firstPageY : this.currentPage.pageY;\n    }\n\n    var _b = this.pagesMatrix.getPageStats(pageX, pageY),\n        x = _b.x,\n        y = _b.y;\n\n    return {\n      pageX: pageX,\n      pageY: pageY,\n      x: x,\n      y: y\n    };\n  };\n\n  SlidePages.prototype.getExposedPage = function (page) {\n    var exposedPage = extend({}, page); // only pageX or pageY need fix\n\n    if (this.loopX) {\n      exposedPage.pageX = this.fixedPage(exposedPage.pageX, this.pagesMatrix.pageLengthOfX - 2);\n    }\n\n    if (this.loopY) {\n      exposedPage.pageY = this.fixedPage(exposedPage.pageY, this.pagesMatrix.pageLengthOfY - 2);\n    }\n\n    return exposedPage;\n  };\n\n  SlidePages.prototype.getExposedPageByPageIndex = function (pageIndexX, pageIndexY) {\n    var page = {\n      pageX: pageIndexX,\n      pageY: pageIndexY\n    };\n\n    if (this.loopX) {\n      page.pageX = pageIndexX + 1;\n    }\n\n    if (this.loopY) {\n      page.pageY = pageIndexY + 1;\n    }\n\n    var _a = this.pagesMatrix.getPageStats(page.pageX, page.pageY),\n        x = _a.x,\n        y = _a.y;\n\n    return {\n      x: x,\n      y: y,\n      pageX: pageIndexX,\n      pageY: pageIndexY\n    };\n  };\n\n  SlidePages.prototype.getWillChangedPage = function (page) {\n    page = extend({}, page); // Page need fix\n\n    if (this.loopX) {\n      page.pageX = this.fixedPage(page.pageX, this.pagesMatrix.pageLengthOfX - 2);\n      page.x = this.pagesMatrix.getPageStats(page.pageX + 1, 0).x;\n    }\n\n    if (this.loopY) {\n      page.pageY = this.fixedPage(page.pageY, this.pagesMatrix.pageLengthOfY - 2);\n      page.y = this.pagesMatrix.getPageStats(0, page.pageY + 1).y;\n    }\n\n    return page;\n  };\n\n  SlidePages.prototype.fixedPage = function (page, realPageLen) {\n    var pageIndex = [];\n\n    for (var i = 0; i < realPageLen; i++) {\n      pageIndex.push(i);\n    }\n\n    pageIndex.unshift(realPageLen - 1);\n    pageIndex.push(0);\n    return pageIndex[page];\n  };\n\n  SlidePages.prototype.getPageStats = function () {\n    return this.pagesMatrix.getPageStats(this.currentPage.pageX, this.currentPage.pageY);\n  };\n\n  SlidePages.prototype.getValidPageIndex = function (x, y) {\n    var lastX = this.pagesMatrix.pageLengthOfX - 1;\n    var lastY = this.pagesMatrix.pageLengthOfY - 1;\n    var firstX = 0;\n    var firstY = 0;\n\n    if (this.loopX) {\n      x += 1;\n      firstX = firstX + 1;\n      lastX = lastX - 1;\n    }\n\n    if (this.loopY) {\n      y += 1;\n      firstY = firstY + 1;\n      lastY = lastY - 1;\n    }\n\n    x = between(x, firstX, lastX);\n    y = between(y, firstY, lastY);\n    return {\n      pageX: x,\n      pageY: y\n    };\n  };\n\n  SlidePages.prototype.nextPageIndex = function () {\n    return this.getPageIndexByDirection(\"positive\"\n    /* Positive */\n    );\n  };\n\n  SlidePages.prototype.prevPageIndex = function () {\n    return this.getPageIndexByDirection(\"negative\"\n    /* Negative */\n    );\n  };\n\n  SlidePages.prototype.getNearestPage = function (x, y) {\n    var pageIndex = this.pagesMatrix.getNearestPageIndex(x, y);\n    var pageX = pageIndex.pageX,\n        pageY = pageIndex.pageY;\n    var newX = this.pagesMatrix.getPageStats(pageX, 0).x;\n    var newY = this.pagesMatrix.getPageStats(0, pageY).y;\n    return {\n      x: newX,\n      y: newY,\n      pageX: pageX,\n      pageY: pageY\n    };\n  };\n\n  SlidePages.prototype.getPageByDirection = function (page, directionX, directionY) {\n    var pageX = page.pageX,\n        pageY = page.pageY;\n\n    if (pageX === this.currentPage.pageX) {\n      pageX = between(pageX + directionX, 0, this.pagesMatrix.pageLengthOfX - 1);\n    }\n\n    if (pageY === this.currentPage.pageY) {\n      pageY = between(pageY + directionY, 0, this.pagesMatrix.pageLengthOfY - 1);\n    }\n\n    var x = this.pagesMatrix.getPageStats(pageX, 0).x;\n    var y = this.pagesMatrix.getPageStats(0, pageY).y;\n    return {\n      x: x,\n      y: y,\n      pageX: pageX,\n      pageY: pageY\n    };\n  };\n\n  SlidePages.prototype.resetLoopPage = function () {\n    if (this.loopX) {\n      if (this.currentPage.pageX === 0) {\n        return {\n          pageX: this.pagesMatrix.pageLengthOfX - 2,\n          pageY: this.currentPage.pageY\n        };\n      }\n\n      if (this.currentPage.pageX === this.pagesMatrix.pageLengthOfX - 1) {\n        return {\n          pageX: 1,\n          pageY: this.currentPage.pageY\n        };\n      }\n    }\n\n    if (this.loopY) {\n      if (this.currentPage.pageY === 0) {\n        return {\n          pageX: this.currentPage.pageX,\n          pageY: this.pagesMatrix.pageLengthOfY - 2\n        };\n      }\n\n      if (this.currentPage.pageY === this.pagesMatrix.pageLengthOfY - 1) {\n        return {\n          pageX: this.currentPage.pageX,\n          pageY: 1\n        };\n      }\n    }\n  };\n\n  SlidePages.prototype.getPageIndexByDirection = function (direction) {\n    var x = this.currentPage.pageX;\n    var y = this.currentPage.pageY;\n\n    if (this.slideX) {\n      x = direction === \"negative\"\n      /* Negative */\n      ? x - 1 : x + 1;\n    }\n\n    if (this.slideY) {\n      y = direction === \"negative\"\n      /* Negative */\n      ? y - 1 : y + 1;\n    }\n\n    return {\n      pageX: x,\n      pageY: y\n    };\n  };\n\n  SlidePages.prototype.checkSlideLoop = function () {\n    this.wannaLoop = this.slideOptions.loop;\n\n    if (this.pagesMatrix.pageLengthOfX > 1) {\n      this.slideX = true;\n    } else {\n      this.slideX = false;\n    }\n\n    if (this.pagesMatrix.pages[0] && this.pagesMatrix.pageLengthOfY > 1) {\n      this.slideY = true;\n    } else {\n      this.slideY = false;\n    }\n\n    this.loopX = this.wannaLoop && this.slideX;\n    this.loopY = this.wannaLoop && this.slideY;\n\n    if (this.slideX && this.slideY) {\n      warn('slide does not support two direction at the same time.');\n    }\n  };\n\n  return SlidePages;\n}();\n\nvar sourcePrefix$4 = 'plugins.slide';\nvar propertiesMap$4 = [{\n  key: 'next',\n  name: 'next'\n}, {\n  key: 'prev',\n  name: 'prev'\n}, {\n  key: 'goToPage',\n  name: 'goToPage'\n}, {\n  key: 'getCurrentPage',\n  name: 'getCurrentPage'\n}, {\n  key: 'startPlay',\n  name: 'startPlay'\n}, {\n  key: 'pausePlay',\n  name: 'pausePlay'\n}];\nvar propertiesConfig$4 = propertiesMap$4.map(function (item) {\n  return {\n    key: item.key,\n    sourceKey: sourcePrefix$4 + \".\" + item.name\n  };\n});\n\nvar samePage = function (p1, p2) {\n  return p1.pageX === p2.pageX && p1.pageY === p2.pageY;\n};\n\nvar Slide =\n/** @class */\nfunction () {\n  function Slide(scroll) {\n    this.scroll = scroll;\n    this.cachedClonedPageDOM = [];\n    this.resetLooping = false;\n    this.autoplayTimer = 0;\n\n    if (!this.satisfyInitialization()) {\n      return;\n    }\n\n    this.init();\n  }\n\n  Slide.prototype.satisfyInitialization = function () {\n    if (this.scroll.scroller.content.children.length <= 0) {\n      warn(\"slide need at least one slide page to be initialised.\" + \"please check your DOM layout.\");\n      return false;\n    }\n\n    return true;\n  };\n\n  Slide.prototype.init = function () {\n    this.willChangeToPage = extend({}, BASE_PAGE);\n    this.handleBScroll();\n    this.handleOptions();\n    this.handleHooks();\n    this.createPages();\n  };\n\n  Slide.prototype.createPages = function () {\n    this.pages = new SlidePages(this.scroll, this.options);\n  };\n\n  Slide.prototype.handleBScroll = function () {\n    this.scroll.registerType(['slideWillChange', 'slidePageChanged']);\n    this.scroll.proxy(propertiesConfig$4);\n  };\n\n  Slide.prototype.handleOptions = function () {\n    var userOptions = this.scroll.options.slide === true ? {} : this.scroll.options.slide;\n    var defaultOptions = {\n      loop: true,\n      threshold: 0.1,\n      speed: 400,\n      easing: ease.bounce,\n      listenFlick: true,\n      autoplay: true,\n      interval: 3000,\n      startPageXIndex: 0,\n      startPageYIndex: 0\n    };\n    this.options = extend(defaultOptions, userOptions);\n  };\n\n  Slide.prototype.handleLoop = function (prevSlideContent) {\n    var loop = this.options.loop;\n    var slideContent = this.scroll.scroller.content;\n    var currentSlidePagesLength = slideContent.children.length; // only should respect loop scene\n\n    if (loop) {\n      if (slideContent !== prevSlideContent) {\n        this.resetLoopChangedStatus();\n        this.removeClonedSlidePage(prevSlideContent);\n        currentSlidePagesLength > 1 && this.cloneFirstAndLastSlidePage(slideContent);\n      } else {\n        // many pages reduce to one page\n        if (currentSlidePagesLength === 3 && this.initialised) {\n          this.removeClonedSlidePage(slideContent);\n          this.moreToOnePageInLoop = true;\n          this.oneToMorePagesInLoop = false;\n        } else if (currentSlidePagesLength > 1) {\n          // one page increases to many page\n          if (this.initialised && this.cachedClonedPageDOM.length === 0) {\n            this.oneToMorePagesInLoop = true;\n            this.moreToOnePageInLoop = false;\n          } else {\n            this.removeClonedSlidePage(slideContent);\n            this.resetLoopChangedStatus();\n          }\n\n          this.cloneFirstAndLastSlidePage(slideContent);\n        } else {\n          this.resetLoopChangedStatus();\n        }\n      }\n    }\n  };\n\n  Slide.prototype.resetLoopChangedStatus = function () {\n    this.moreToOnePageInLoop = false;\n    this.oneToMorePagesInLoop = false;\n  };\n\n  Slide.prototype.handleHooks = function () {\n    var _this = this;\n\n    var scrollHooks = this.scroll.hooks;\n    var scrollerHooks = this.scroll.scroller.hooks;\n    var listenFlick = this.options.listenFlick;\n    this.prevContent = this.scroll.scroller.content;\n    this.hooksFn = []; // scroll\n\n    this.registerHooks(this.scroll, this.scroll.eventTypes.beforeScrollStart, this.pausePlay);\n    this.registerHooks(this.scroll, this.scroll.eventTypes.scrollEnd, this.modifyCurrentPage);\n    this.registerHooks(this.scroll, this.scroll.eventTypes.scrollEnd, this.startPlay); // for mousewheel event\n\n    if (this.scroll.eventTypes.mousewheelMove) {\n      this.registerHooks(this.scroll, this.scroll.eventTypes.mousewheelMove, function () {\n        // prevent default action of mousewheelMove\n        return true;\n      });\n      this.registerHooks(this.scroll, this.scroll.eventTypes.mousewheelEnd, function (delta) {\n        if (delta.directionX === 1\n        /* Positive */\n        || delta.directionY === 1\n        /* Positive */\n        ) {\n          _this.next();\n        }\n\n        if (delta.directionX === -1\n        /* Negative */\n        || delta.directionY === -1\n        /* Negative */\n        ) {\n          _this.prev();\n        }\n      });\n    } // scrollHooks\n\n\n    this.registerHooks(scrollHooks, scrollHooks.eventTypes.refresh, this.refreshHandler);\n    this.registerHooks(scrollHooks, scrollHooks.eventTypes.destroy, this.destroy); // scroller\n\n    this.registerHooks(scrollerHooks, scrollerHooks.eventTypes.beforeRefresh, function () {\n      _this.handleLoop(_this.prevContent);\n\n      _this.setSlideInlineStyle();\n    });\n    this.registerHooks(scrollerHooks, scrollerHooks.eventTypes.momentum, this.modifyScrollMetaHandler);\n    this.registerHooks(scrollerHooks, scrollerHooks.eventTypes.scroll, this.scrollHandler); // a click operation will clearTimer, so restart a new one\n\n    this.registerHooks(scrollerHooks, scrollerHooks.eventTypes.checkClick, this.startPlay);\n\n    if (listenFlick) {\n      this.registerHooks(scrollerHooks, scrollerHooks.eventTypes.flick, this.flickHandler);\n    }\n  };\n\n  Slide.prototype.startPlay = function () {\n    var _this = this;\n\n    var _a = this.options,\n        interval = _a.interval,\n        autoplay = _a.autoplay;\n\n    if (autoplay) {\n      clearTimeout(this.autoplayTimer);\n      this.autoplayTimer = window.setTimeout(function () {\n        _this.next();\n      }, interval);\n    }\n  };\n\n  Slide.prototype.pausePlay = function () {\n    if (this.options.autoplay) {\n      clearTimeout(this.autoplayTimer);\n    }\n  };\n\n  Slide.prototype.setSlideInlineStyle = function () {\n    var styleConfigurations = [{\n      direction: 'scrollX',\n      sizeType: 'offsetWidth',\n      styleType: 'width'\n    }, {\n      direction: 'scrollY',\n      sizeType: 'offsetHeight',\n      styleType: 'height'\n    }];\n    var _a = this.scroll.scroller,\n        slideContent = _a.content,\n        slideWrapper = _a.wrapper;\n    var scrollOptions = this.scroll.options;\n    styleConfigurations.forEach(function (_a) {\n      var direction = _a.direction,\n          sizeType = _a.sizeType,\n          styleType = _a.styleType; // wanna scroll in this direction\n\n      if (scrollOptions[direction]) {\n        var size = slideWrapper[sizeType];\n        var children = slideContent.children;\n        var length_1 = children.length;\n\n        for (var i = 0; i < length_1; i++) {\n          var slidePageDOM = children[i];\n          slidePageDOM.style[styleType] = size + 'px';\n        }\n\n        slideContent.style[styleType] = size * length_1 + 'px';\n      }\n    });\n  };\n\n  Slide.prototype.next = function (time, easing) {\n    var _a = this.pages.nextPageIndex(),\n        pageX = _a.pageX,\n        pageY = _a.pageY;\n\n    this.goTo(pageX, pageY, time, easing);\n  };\n\n  Slide.prototype.prev = function (time, easing) {\n    var _a = this.pages.prevPageIndex(),\n        pageX = _a.pageX,\n        pageY = _a.pageY;\n\n    this.goTo(pageX, pageY, time, easing);\n  };\n\n  Slide.prototype.goToPage = function (pageX, pageY, time, easing) {\n    var pageIndex = this.pages.getValidPageIndex(pageX, pageY);\n    this.goTo(pageIndex.pageX, pageIndex.pageY, time, easing);\n  };\n\n  Slide.prototype.getCurrentPage = function () {\n    return this.exposedPage || this.pages.getInitialPage(false, true);\n  };\n\n  Slide.prototype.setCurrentPage = function (page) {\n    this.pages.setCurrentPage(page);\n    this.exposedPage = this.pages.getExposedPage(page);\n  };\n\n  Slide.prototype.nearestPage = function (x, y) {\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n    var maxScrollPosX = scrollBehaviorX.maxScrollPos,\n        minScrollPosX = scrollBehaviorX.minScrollPos;\n    var maxScrollPosY = scrollBehaviorY.maxScrollPos,\n        minScrollPosY = scrollBehaviorY.minScrollPos;\n    return this.pages.getNearestPage(between(x, maxScrollPosX, minScrollPosX), between(y, maxScrollPosY, minScrollPosY));\n  };\n\n  Slide.prototype.satisfyThreshold = function (x, y) {\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n    var satisfied = true;\n\n    if (Math.abs(x - scrollBehaviorX.absStartPos) <= this.thresholdX && Math.abs(y - scrollBehaviorY.absStartPos) <= this.thresholdY) {\n      satisfied = false;\n    }\n\n    return satisfied;\n  };\n\n  Slide.prototype.refreshHandler = function (content) {\n    var _this = this;\n\n    if (!this.satisfyInitialization()) {\n      return;\n    }\n\n    this.pages.refresh();\n    this.computeThreshold();\n    var contentChanged = this.contentChanged = this.prevContent !== content;\n\n    if (contentChanged) {\n      this.prevContent = content;\n    }\n\n    var initPage = this.pages.getInitialPage(this.oneToMorePagesInLoop || this.moreToOnePageInLoop, contentChanged || !this.initialised);\n\n    if (this.initialised) {\n      this.goTo(initPage.pageX, initPage.pageY, 0);\n    } else {\n      this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.beforeInitialScrollTo, function (position) {\n        _this.initialised = true;\n        position.x = initPage.x;\n        position.y = initPage.y;\n      });\n    }\n\n    this.startPlay();\n  };\n\n  Slide.prototype.computeThreshold = function () {\n    var threshold = this.options.threshold; // Integer\n\n    if (threshold % 1 === 0) {\n      this.thresholdX = threshold;\n      this.thresholdY = threshold;\n    } else {\n      // decimal\n      var _a = this.pages.getPageStats(),\n          width = _a.width,\n          height = _a.height;\n\n      this.thresholdX = Math.round(width * threshold);\n      this.thresholdY = Math.round(height * threshold);\n    }\n  };\n\n  Slide.prototype.cloneFirstAndLastSlidePage = function (slideContent) {\n    var children = slideContent.children;\n    var preprendDOM = children[children.length - 1].cloneNode(true);\n    var appendDOM = children[0].cloneNode(true);\n    prepend(preprendDOM, slideContent);\n    slideContent.appendChild(appendDOM);\n    this.cachedClonedPageDOM = [preprendDOM, appendDOM];\n  };\n\n  Slide.prototype.removeClonedSlidePage = function (slideContent) {\n    // maybe slideContent has removed from DOM Tree\n    var slidePages = slideContent && slideContent.children || [];\n\n    if (slidePages.length) {\n      this.cachedClonedPageDOM.forEach(function (el) {\n        removeChild(slideContent, el);\n      });\n    }\n\n    this.cachedClonedPageDOM = [];\n  };\n\n  Slide.prototype.modifyCurrentPage = function (point) {\n    var _a = this.getCurrentPage(),\n        prevExposedPageX = _a.pageX,\n        prevExposedPageY = _a.pageY;\n\n    var newPage = this.nearestPage(point.x, point.y);\n    this.setCurrentPage(newPage);\n    /* istanbul ignore if */\n\n    if (this.contentChanged) {\n      this.contentChanged = false;\n      return true;\n    }\n\n    var _b = this.getCurrentPage(),\n        currentExposedPageX = _b.pageX,\n        currentExposedPageY = _b.pageY;\n\n    this.pageWillChangeTo(newPage); // loop is true, and one page becomes many pages when call bs.refresh\n\n    if (this.oneToMorePagesInLoop) {\n      this.oneToMorePagesInLoop = false;\n      return true;\n    } // loop is true, and many page becomes one page when call bs.refresh\n    // if prevPage > 0, dispatch slidePageChanged and scrollEnd events\n\n    /* istanbul ignore if */\n\n\n    if (this.moreToOnePageInLoop && prevExposedPageX === 0 && prevExposedPageY === 0) {\n      this.moreToOnePageInLoop = false;\n      return true;\n    }\n\n    if (prevExposedPageX !== currentExposedPageX || prevExposedPageY !== currentExposedPageY) {\n      // only trust pageX & pageY when loop is true\n      var page = this.pages.getExposedPageByPageIndex(currentExposedPageX, currentExposedPageY);\n      this.scroll.trigger(this.scroll.eventTypes.slidePageChanged, page);\n    } // triggered by resetLoop\n\n\n    if (this.resetLooping) {\n      this.resetLooping = false;\n      return;\n    }\n\n    var changePage = this.pages.resetLoopPage();\n\n    if (changePage) {\n      this.resetLooping = true;\n      this.goTo(changePage.pageX, changePage.pageY, 0); // stop user's scrollEnd\n      // since it is a seamless scroll\n\n      return true;\n    }\n  };\n\n  Slide.prototype.goTo = function (pageX, pageY, time, easing) {\n    var newPage = this.pages.getInternalPage(pageX, pageY);\n    var scrollEasing = easing || this.options.easing || ease.bounce;\n    var x = newPage.x,\n        y = newPage.y;\n    var deltaX = x - this.scroll.scroller.scrollBehaviorX.currentPos;\n    var deltaY = y - this.scroll.scroller.scrollBehaviorY.currentPos;\n    /* istanbul ignore if */\n\n    if (!deltaX && !deltaY) {\n      this.scroll.scroller.togglePointerEvents(true);\n      return;\n    }\n\n    time = time === undefined ? this.getEaseTime(deltaX, deltaY) : time;\n    this.scroll.scroller.scrollTo(x, y, time, scrollEasing);\n  };\n\n  Slide.prototype.flickHandler = function () {\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n    var currentPosX = scrollBehaviorX.currentPos,\n        startPosX = scrollBehaviorX.startPos,\n        directionX = scrollBehaviorX.direction;\n    var currentPosY = scrollBehaviorY.currentPos,\n        startPosY = scrollBehaviorY.startPos,\n        directionY = scrollBehaviorY.direction;\n    var _b = this.pages.currentPage,\n        pageX = _b.pageX,\n        pageY = _b.pageY;\n    var time = this.getEaseTime(currentPosX - startPosX, currentPosY - startPosY);\n    this.goTo(pageX + directionX, pageY + directionY, time);\n  };\n\n  Slide.prototype.getEaseTime = function (deltaX, deltaY) {\n    return this.options.speed || Math.max(Math.max(Math.min(Math.abs(deltaX), 1000), Math.min(Math.abs(deltaY), 1000)), 300);\n  };\n\n  Slide.prototype.modifyScrollMetaHandler = function (scrollMeta) {\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY,\n        animater = _a.animater;\n    var newX = scrollMeta.newX;\n    var newY = scrollMeta.newY;\n    var newPage = this.satisfyThreshold(newX, newY) || animater.forceStopped ? this.pages.getPageByDirection(this.nearestPage(newX, newY), scrollBehaviorX.direction, scrollBehaviorY.direction) : this.pages.currentPage;\n    scrollMeta.time = this.getEaseTime(scrollMeta.newX - newPage.x, scrollMeta.newY - newPage.y);\n    scrollMeta.newX = newPage.x;\n    scrollMeta.newY = newPage.y;\n    scrollMeta.easing = this.options.easing || ease.bounce;\n  };\n\n  Slide.prototype.scrollHandler = function (_a) {\n    var x = _a.x,\n        y = _a.y;\n\n    if (this.satisfyThreshold(x, y)) {\n      var newPage = this.nearestPage(x, y);\n      this.pageWillChangeTo(newPage);\n    }\n  };\n\n  Slide.prototype.pageWillChangeTo = function (newPage) {\n    var changeToPage = this.pages.getWillChangedPage(newPage);\n\n    if (!samePage(this.willChangeToPage, changeToPage)) {\n      this.willChangeToPage = changeToPage;\n      this.scroll.trigger(this.scroll.eventTypes.slideWillChange, this.willChangeToPage);\n    }\n  };\n\n  Slide.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  Slide.prototype.destroy = function () {\n    var slideContent = this.scroll.scroller.content;\n    var _a = this.options,\n        loop = _a.loop,\n        autoplay = _a.autoplay;\n\n    if (loop) {\n      this.removeClonedSlidePage(slideContent);\n    }\n\n    if (autoplay) {\n      clearTimeout(this.autoplayTimer);\n    }\n\n    this.hooksFn.forEach(function (item) {\n      var hooks = item[0];\n      var hooksName = item[1];\n      var handlerFn = item[2];\n\n      if (hooks.eventTypes[hooksName]) {\n        hooks.off(hooksName, handlerFn);\n      }\n    });\n    this.hooksFn.length = 0;\n  };\n\n  Slide.pluginName = 'slide';\n  return Slide;\n}();\n\nvar sourcePrefix$3 = 'plugins.wheel';\nvar propertiesMap$3 = [{\n  key: 'wheelTo',\n  name: 'wheelTo'\n}, {\n  key: 'getSelectedIndex',\n  name: 'getSelectedIndex'\n}, {\n  key: 'restorePosition',\n  name: 'restorePosition'\n}];\nvar propertiesConfig$3 = propertiesMap$3.map(function (item) {\n  return {\n    key: item.key,\n    sourceKey: sourcePrefix$3 + \".\" + item.name\n  };\n});\nvar WHEEL_INDEX_CHANGED_EVENT_NAME = 'wheelIndexChanged';\nvar CONSTANTS = {\n  rate: 4\n};\n\nvar Wheel =\n/** @class */\nfunction () {\n  function Wheel(scroll) {\n    this.scroll = scroll;\n    this.init();\n  }\n\n  Wheel.prototype.init = function () {\n    this.handleBScroll();\n    this.handleOptions();\n    this.handleHooks(); // init boundary for Wheel\n\n    this.refreshBoundary();\n    this.setSelectedIndex(this.options.selectedIndex);\n  };\n\n  Wheel.prototype.handleBScroll = function () {\n    this.scroll.proxy(propertiesConfig$3);\n    this.scroll.registerType([WHEEL_INDEX_CHANGED_EVENT_NAME]);\n  };\n\n  Wheel.prototype.handleOptions = function () {\n    var userOptions = this.scroll.options.wheel === true ? {} : this.scroll.options.wheel;\n    var defaultOptions = {\n      wheelWrapperClass: 'wheel-scroll',\n      wheelItemClass: 'wheel-item',\n      rotate: 25,\n      adjustTime: 400,\n      selectedIndex: 0,\n      wheelDisabledItemClass: 'wheel-disabled-item'\n    };\n    this.options = extend(defaultOptions, userOptions);\n  };\n\n  Wheel.prototype.handleHooks = function () {\n    var _this = this;\n\n    var scroll = this.scroll;\n    var scroller = this.scroll.scroller;\n    var actionsHandler = scroller.actionsHandler,\n        scrollBehaviorX = scroller.scrollBehaviorX,\n        scrollBehaviorY = scroller.scrollBehaviorY,\n        animater = scroller.animater;\n    var prevContent = scroller.content; // BScroll\n\n    scroll.on(scroll.eventTypes.scrollEnd, function (position) {\n      var index = _this.findNearestValidWheel(position.y).index;\n\n      if (scroller.animater.forceStopped && !_this.isAdjustingPosition) {\n        _this.target = _this.items[index]; // since stopped from an animation.\n        // prevent user's scrollEnd callback triggered twice\n\n        return true;\n      } else {\n        _this.setSelectedIndex(index);\n\n        if (_this.isAdjustingPosition) {\n          _this.isAdjustingPosition = false;\n        }\n      }\n    }); // BScroll.hooks\n\n    this.scroll.hooks.on(this.scroll.hooks.eventTypes.refresh, function (content) {\n      if (content !== prevContent) {\n        prevContent = content;\n\n        _this.setSelectedIndex(_this.options.selectedIndex, true);\n      } // rotate all wheel-items\n      // because position may not change\n\n\n      _this.rotateX(_this.scroll.y); // check we are stop at a disable item or not\n\n\n      _this.wheelTo(_this.selectedIndex, 0);\n    });\n    this.scroll.hooks.on(this.scroll.hooks.eventTypes.beforeInitialScrollTo, function (position) {\n      // selectedIndex has higher priority than bs.options.startY\n      position.x = 0;\n      position.y = -(_this.selectedIndex * _this.itemHeight);\n    }); // Scroller\n\n    scroller.hooks.on(scroller.hooks.eventTypes.checkClick, function () {\n      var index = HTMLCollectionToArray(_this.items).indexOf(_this.target);\n      if (index === -1) return true;\n\n      _this.wheelTo(index, _this.options.adjustTime, ease.swipe);\n\n      return true;\n    });\n    scroller.hooks.on(scroller.hooks.eventTypes.scrollTo, function (endPoint) {\n      endPoint.y = _this.findNearestValidWheel(endPoint.y).y;\n    }); // when content is scrolling\n    // click wheel-item DOM repeatedly and crazily will cause scrollEnd not triggered\n    // so reset forceStopped\n\n    scroller.hooks.on(scroller.hooks.eventTypes.minDistanceScroll, function () {\n      var animater = scroller.animater;\n\n      if (animater.forceStopped === true) {\n        animater.forceStopped = false;\n      }\n    });\n    scroller.hooks.on(scroller.hooks.eventTypes.scrollToElement, function (el, pos) {\n      if (!hasClass(el, _this.options.wheelItemClass)) {\n        return true;\n      } else {\n        pos.top = _this.findNearestValidWheel(pos.top).y;\n      }\n    }); // ActionsHandler\n\n    actionsHandler.hooks.on(actionsHandler.hooks.eventTypes.beforeStart, function (e) {\n      _this.target = e.target;\n    }); // ScrollBehaviorX\n    // Wheel has no x direction now\n\n    scrollBehaviorX.hooks.on(scrollBehaviorX.hooks.eventTypes.computeBoundary, function (boundary) {\n      boundary.maxScrollPos = 0;\n      boundary.minScrollPos = 0;\n    }); // ScrollBehaviorY\n\n    scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.computeBoundary, function (boundary) {\n      _this.items = _this.scroll.scroller.content.children;\n\n      _this.checkWheelAllDisabled();\n\n      _this.itemHeight = _this.items.length > 0 ? scrollBehaviorY.contentSize / _this.items.length : 0;\n      boundary.maxScrollPos = -_this.itemHeight * (_this.items.length - 1);\n      boundary.minScrollPos = 0;\n    });\n    scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.momentum, function (momentumInfo) {\n      momentumInfo.rate = CONSTANTS.rate;\n      momentumInfo.destination = _this.findNearestValidWheel(momentumInfo.destination).y;\n    });\n    scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.end, function (momentumInfo) {\n      var validWheel = _this.findNearestValidWheel(scrollBehaviorY.currentPos);\n\n      momentumInfo.destination = validWheel.y;\n      momentumInfo.duration = _this.options.adjustTime;\n    }); // Animater\n\n    animater.hooks.on(animater.hooks.eventTypes.time, function (time) {\n      _this.transitionDuration(time);\n    });\n    animater.hooks.on(animater.hooks.eventTypes.timeFunction, function (easing) {\n      _this.timeFunction(easing);\n    }); // bs.stop() to make wheel stop at a correct position when pending\n\n    animater.hooks.on(animater.hooks.eventTypes.callStop, function () {\n      var index = _this.findNearestValidWheel(_this.scroll.y).index;\n\n      _this.isAdjustingPosition = true;\n\n      _this.wheelTo(index, 0);\n    }); // Translater\n\n    animater.translater.hooks.on(animater.translater.hooks.eventTypes.translate, function (endPoint) {\n      _this.rotateX(endPoint.y);\n    });\n  };\n\n  Wheel.prototype.refreshBoundary = function () {\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY,\n        content = _a.content;\n    scrollBehaviorX.refresh(content);\n    scrollBehaviorY.refresh(content);\n  };\n\n  Wheel.prototype.setSelectedIndex = function (index, contentChanged) {\n    if (contentChanged === void 0) {\n      contentChanged = false;\n    }\n\n    var prevSelectedIndex = this.selectedIndex;\n    this.selectedIndex = index; // if content DOM changed, should not trigger event\n\n    if (prevSelectedIndex !== index && !contentChanged) {\n      this.scroll.trigger(WHEEL_INDEX_CHANGED_EVENT_NAME, index);\n    }\n  };\n\n  Wheel.prototype.getSelectedIndex = function () {\n    return this.selectedIndex;\n  };\n\n  Wheel.prototype.wheelTo = function (index, time, ease) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (time === void 0) {\n      time = 0;\n    }\n\n    var y = -index * this.itemHeight;\n    this.scroll.scrollTo(0, y, time, ease);\n  };\n\n  Wheel.prototype.restorePosition = function () {\n    // bs is scrolling\n    var isPending = this.scroll.pending;\n\n    if (isPending) {\n      var selectedIndex = this.getSelectedIndex();\n      this.scroll.scroller.animater.clearTimer();\n      this.wheelTo(selectedIndex, 0);\n    }\n  };\n\n  Wheel.prototype.transitionDuration = function (time) {\n    for (var i = 0; i < this.items.length; i++) {\n      this.items[i].style[style.transitionDuration] = time + 'ms';\n    }\n  };\n\n  Wheel.prototype.timeFunction = function (easing) {\n    for (var i = 0; i < this.items.length; i++) {\n      this.items[i].style[style.transitionTimingFunction] = easing;\n    }\n  };\n\n  Wheel.prototype.rotateX = function (y) {\n    var _a = this.options.rotate,\n        rotate = _a === void 0 ? 25 : _a;\n\n    for (var i = 0; i < this.items.length; i++) {\n      var deg = rotate * (y / this.itemHeight + i); // Too small value is invalid in some phones, issue 1026\n\n      var SafeDeg = deg.toFixed(3);\n      this.items[i].style[style.transform] = \"rotateX(\" + SafeDeg + \"deg)\";\n    }\n  };\n\n  Wheel.prototype.findNearestValidWheel = function (y) {\n    y = y > 0 ? 0 : y < this.scroll.maxScrollY ? this.scroll.maxScrollY : y;\n    var currentIndex = Math.abs(Math.round(-y / this.itemHeight));\n    var cacheIndex = currentIndex;\n    var items = this.items;\n    var wheelDisabledItemClassName = this.options.wheelDisabledItemClass; // implement web native select element\n    // first, check whether there is a enable item whose index is smaller than currentIndex\n    // then, check whether there is a enable item whose index is bigger than currentIndex\n    // otherwise, there are all disabled items, just keep currentIndex unchange\n\n    while (currentIndex >= 0) {\n      if (!hasClass(items[currentIndex], wheelDisabledItemClassName)) {\n        break;\n      }\n\n      currentIndex--;\n    }\n\n    if (currentIndex < 0) {\n      currentIndex = cacheIndex;\n\n      while (currentIndex <= items.length - 1) {\n        if (!hasClass(items[currentIndex], wheelDisabledItemClassName)) {\n          break;\n        }\n\n        currentIndex++;\n      }\n    } // keep it unchange when all the items are disabled\n\n\n    if (currentIndex === items.length) {\n      currentIndex = cacheIndex;\n    } // when all the items are disabled, selectedIndex should always be -1\n\n\n    return {\n      index: this.wheelItemsAllDisabled ? -1 : currentIndex,\n      y: -currentIndex * this.itemHeight\n    };\n  };\n\n  Wheel.prototype.checkWheelAllDisabled = function () {\n    var wheelDisabledItemClassName = this.options.wheelDisabledItemClass;\n    var items = this.items;\n    this.wheelItemsAllDisabled = true;\n\n    for (var i = 0; i < items.length; i++) {\n      if (!hasClass(items[i], wheelDisabledItemClassName)) {\n        this.wheelItemsAllDisabled = false;\n        break;\n      }\n    }\n  };\n\n  Wheel.pluginName = 'wheel';\n  return Wheel;\n}();\n\nvar sourcePrefix$2 = 'plugins.zoom';\nvar propertiesMap$2 = [{\n  key: 'zoomTo',\n  name: 'zoomTo'\n}];\nvar propertiesConfig$2 = propertiesMap$2.map(function (item) {\n  return {\n    key: item.key,\n    sourceKey: sourcePrefix$2 + \".\" + item.name\n  };\n});\nvar TWO_FINGERS = 2;\nvar RAW_SCALE = 1;\n\nvar Zoom =\n/** @class */\nfunction () {\n  function Zoom(scroll) {\n    this.scroll = scroll;\n    this.scale = RAW_SCALE;\n    this.prevScale = 1;\n    this.init();\n  }\n\n  Zoom.prototype.init = function () {\n    this.handleBScroll();\n    this.handleOptions();\n    this.handleHooks();\n    this.tryInitialZoomTo(this.zoomOpt);\n  };\n\n  Zoom.prototype.zoomTo = function (scale, x, y, bounceTime) {\n    var _a = this.resolveOrigin(x, y),\n        originX = _a.originX,\n        originY = _a.originY;\n\n    var origin = {\n      x: originX,\n      y: originY,\n      baseScale: this.scale\n    };\n\n    this._doZoomTo(scale, origin, bounceTime, true);\n  };\n\n  Zoom.prototype.handleBScroll = function () {\n    this.scroll.proxy(propertiesConfig$2);\n    this.scroll.registerType(['beforeZoomStart', 'zoomStart', 'zooming', 'zoomEnd']);\n  };\n\n  Zoom.prototype.handleOptions = function () {\n    var userOptions = this.scroll.options.zoom === true ? {} : this.scroll.options.zoom;\n    var defaultOptions = {\n      start: 1,\n      min: 1,\n      max: 4,\n      initialOrigin: [0, 0],\n      minimalZoomDistance: 5,\n      bounceTime: 800\n    };\n    this.zoomOpt = extend(defaultOptions, userOptions);\n  };\n\n  Zoom.prototype.handleHooks = function () {\n    var _this = this;\n\n    var scroll = this.scroll;\n    var scroller = this.scroll.scroller;\n    this.wrapper = this.scroll.scroller.wrapper;\n    this.setTransformOrigin(this.scroll.scroller.content);\n    var scrollBehaviorX = scroller.scrollBehaviorX;\n    var scrollBehaviorY = scroller.scrollBehaviorY;\n    this.hooksFn = []; // BScroll\n\n    this.registerHooks(scroll.hooks, scroll.hooks.eventTypes.contentChanged, function (content) {\n      _this.setTransformOrigin(content);\n\n      _this.scale = RAW_SCALE;\n\n      _this.tryInitialZoomTo(_this.zoomOpt);\n    });\n    this.registerHooks(scroll.hooks, scroll.hooks.eventTypes.beforeInitialScrollTo, function () {\n      // if perform a zoom action, we should prevent initial scroll when initialised\n      if (_this.zoomOpt.start !== RAW_SCALE) {\n        return true;\n      }\n    }); // enlarge boundary\n\n    this.registerHooks(scrollBehaviorX.hooks, scrollBehaviorX.hooks.eventTypes.beforeComputeBoundary, function () {\n      // content may change, don't cache it's size\n      var contentSize = getRect(_this.scroll.scroller.content);\n      scrollBehaviorX.contentSize = Math.floor(contentSize.width * _this.scale);\n    });\n    this.registerHooks(scrollBehaviorY.hooks, scrollBehaviorY.hooks.eventTypes.beforeComputeBoundary, function () {\n      // content may change, don't cache it's size\n      var contentSize = getRect(_this.scroll.scroller.content);\n      scrollBehaviorY.contentSize = Math.floor(contentSize.height * _this.scale);\n    }); // touch event\n\n    this.registerHooks(scroller.actions.hooks, scroller.actions.hooks.eventTypes.start, function (e) {\n      var numberOfFingers = e.touches && e.touches.length || 0;\n\n      _this.fingersOperation(numberOfFingers);\n\n      if (numberOfFingers === TWO_FINGERS) {\n        _this.zoomStart(e);\n      }\n    });\n    this.registerHooks(scroller.actions.hooks, scroller.actions.hooks.eventTypes.beforeMove, function (e) {\n      var numberOfFingers = e.touches && e.touches.length || 0;\n\n      _this.fingersOperation(numberOfFingers);\n\n      if (numberOfFingers === TWO_FINGERS) {\n        _this.zoom(e);\n\n        return true;\n      }\n    });\n    this.registerHooks(scroller.actions.hooks, scroller.actions.hooks.eventTypes.beforeEnd, function (e) {\n      var numberOfFingers = _this.fingersOperation();\n\n      if (numberOfFingers === TWO_FINGERS) {\n        _this.zoomEnd();\n\n        return true;\n      }\n    });\n    this.registerHooks(scroller.translater.hooks, scroller.translater.hooks.eventTypes.beforeTranslate, function (transformStyle, point) {\n      var scale = point.scale ? point.scale : _this.prevScale;\n      _this.prevScale = scale;\n      transformStyle.push(\"scale(\" + scale + \")\");\n    });\n    this.registerHooks(scroller.hooks, scroller.hooks.eventTypes.scrollEnd, function () {\n      if (_this.fingersOperation() === TWO_FINGERS) {\n        _this.scroll.trigger(_this.scroll.eventTypes.zoomEnd, {\n          scale: _this.scale\n        });\n      }\n    });\n    this.registerHooks(this.scroll.hooks, 'destroy', this.destroy);\n  };\n\n  Zoom.prototype.setTransformOrigin = function (content) {\n    content.style[style.transformOrigin] = '0 0';\n  };\n\n  Zoom.prototype.tryInitialZoomTo = function (options) {\n    var start = options.start,\n        initialOrigin = options.initialOrigin;\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n\n    if (start !== RAW_SCALE) {\n      // Movable plugin may wanna modify minScrollPos or maxScrollPos\n      // so we force Movable to caculate them\n      this.resetBoundaries([scrollBehaviorX, scrollBehaviorY]);\n      this.zoomTo(start, initialOrigin[0], initialOrigin[1], 0);\n    }\n  }; // getter or setter operation\n\n\n  Zoom.prototype.fingersOperation = function (amounts) {\n    if (typeof amounts === 'number') {\n      this.numberOfFingers = amounts;\n    } else {\n      return this.numberOfFingers;\n    }\n  };\n\n  Zoom.prototype._doZoomTo = function (scale, origin, time, useCurrentPos) {\n    var _this = this;\n\n    if (time === void 0) {\n      time = this.zoomOpt.bounceTime;\n    }\n\n    if (useCurrentPos === void 0) {\n      useCurrentPos = false;\n    }\n\n    var _a = this.zoomOpt,\n        min = _a.min,\n        max = _a.max;\n    var fromScale = this.scale;\n    var toScale = between(scale, min, max);\n\n    (function () {\n      if (time === 0) {\n        _this.scroll.trigger(_this.scroll.eventTypes.zooming, {\n          scale: toScale\n        });\n\n        return;\n      }\n\n      if (time > 0) {\n        var timer_1;\n        var startTime_1 = getNow();\n        var endTime_1 = startTime_1 + time;\n\n        var scheduler_1 = function () {\n          var now = getNow();\n\n          if (now >= endTime_1) {\n            _this.scroll.trigger(_this.scroll.eventTypes.zooming, {\n              scale: toScale\n            });\n\n            cancelAnimationFrame(timer_1);\n            return;\n          }\n\n          var ratio = ease.bounce.fn((now - startTime_1) / time);\n          var currentScale = ratio * (toScale - fromScale) + fromScale;\n\n          _this.scroll.trigger(_this.scroll.eventTypes.zooming, {\n            scale: currentScale\n          });\n\n          timer_1 = requestAnimationFrame(scheduler_1);\n        }; // start scheduler job\n\n\n        scheduler_1();\n      }\n    })(); // suppose you are zooming by two fingers\n\n\n    this.fingersOperation(2);\n\n    this._zoomTo(toScale, fromScale, origin, time, useCurrentPos);\n  };\n\n  Zoom.prototype._zoomTo = function (toScale, fromScale, origin, time, useCurrentPos) {\n    if (useCurrentPos === void 0) {\n      useCurrentPos = false;\n    }\n\n    var ratio = toScale / origin.baseScale;\n    this.setScale(toScale);\n    var scroller = this.scroll.scroller;\n    var scrollBehaviorX = scroller.scrollBehaviorX,\n        scrollBehaviorY = scroller.scrollBehaviorY;\n    this.resetBoundaries([scrollBehaviorX, scrollBehaviorY]); // position is restrained in boundary\n\n    var newX = this.getNewPos(origin.x, ratio, scrollBehaviorX, true, useCurrentPos);\n    var newY = this.getNewPos(origin.y, ratio, scrollBehaviorY, true, useCurrentPos);\n\n    if (scrollBehaviorX.currentPos !== Math.round(newX) || scrollBehaviorY.currentPos !== Math.round(newY) || toScale !== fromScale) {\n      scroller.scrollTo(newX, newY, time, ease.bounce, {\n        start: {\n          scale: fromScale\n        },\n        end: {\n          scale: toScale\n        }\n      });\n    }\n  };\n\n  Zoom.prototype.resolveOrigin = function (x, y) {\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n    var resolveFormula = {\n      left: function () {\n        return 0;\n      },\n      top: function () {\n        return 0;\n      },\n      right: function () {\n        return scrollBehaviorX.contentSize;\n      },\n      bottom: function () {\n        return scrollBehaviorY.contentSize;\n      },\n      center: function (index) {\n        var baseSize = index === 0 ? scrollBehaviorX.contentSize : scrollBehaviorY.contentSize;\n        return baseSize / 2;\n      }\n    };\n    return {\n      originX: typeof x === 'number' ? x : resolveFormula[x](0),\n      originY: typeof y === 'number' ? y : resolveFormula[y](1)\n    };\n  };\n\n  Zoom.prototype.zoomStart = function (e) {\n    var firstFinger = e.touches[0];\n    var secondFinger = e.touches[1];\n    this.startDistance = this.getFingerDistance(e);\n    this.startScale = this.scale;\n\n    var _a = offsetToBody(this.wrapper),\n        left = _a.left,\n        top = _a.top;\n\n    this.origin = {\n      x: Math.abs(firstFinger.pageX + secondFinger.pageX) / 2 + left - this.scroll.x,\n      y: Math.abs(firstFinger.pageY + secondFinger.pageY) / 2 + top - this.scroll.y,\n      baseScale: this.startScale\n    };\n    this.scroll.trigger(this.scroll.eventTypes.beforeZoomStart);\n  };\n\n  Zoom.prototype.zoom = function (e) {\n    var currentDistance = this.getFingerDistance(e); // at least minimalZoomDistance pixels for the zoom to initiate\n\n    if (!this.zoomed && Math.abs(currentDistance - this.startDistance) < this.zoomOpt.minimalZoomDistance) {\n      return;\n    } // when out of boundary , perform a damping algorithm\n\n\n    var endScale = this.dampingScale(currentDistance / this.startDistance * this.startScale);\n    var ratio = endScale / this.startScale;\n    this.setScale(endScale);\n\n    if (!this.zoomed) {\n      this.zoomed = true;\n      this.scroll.trigger(this.scroll.eventTypes.zoomStart);\n    }\n\n    var scroller = this.scroll.scroller;\n    var scrollBehaviorX = scroller.scrollBehaviorX,\n        scrollBehaviorY = scroller.scrollBehaviorY;\n    var x = this.getNewPos(this.origin.x, ratio, scrollBehaviorX, false, false);\n    var y = this.getNewPos(this.origin.y, ratio, scrollBehaviorY, false, false);\n    this.scroll.trigger(this.scroll.eventTypes.zooming, {\n      scale: this.scale\n    });\n    scroller.translater.translate({\n      x: x,\n      y: y,\n      scale: endScale\n    });\n  };\n\n  Zoom.prototype.zoomEnd = function () {\n    if (!this.zoomed) return; // if out of boundary, do rebound!\n\n    if (this.shouldRebound()) {\n      this._doZoomTo(this.scale, this.origin, this.zoomOpt.bounceTime);\n\n      return;\n    }\n\n    this.scroll.trigger(this.scroll.eventTypes.zoomEnd, {\n      scale: this.scale\n    });\n  };\n\n  Zoom.prototype.getFingerDistance = function (e) {\n    var firstFinger = e.touches[0];\n    var secondFinger = e.touches[1];\n    var deltaX = Math.abs(firstFinger.pageX - secondFinger.pageX);\n    var deltaY = Math.abs(firstFinger.pageY - secondFinger.pageY);\n    return getDistance(deltaX, deltaY);\n  };\n\n  Zoom.prototype.shouldRebound = function () {\n    var _a = this.zoomOpt,\n        min = _a.min,\n        max = _a.max;\n    var currentScale = this.scale; // scale exceeded!\n\n    if (currentScale !== between(currentScale, min, max)) {\n      return true;\n    }\n\n    var _b = this.scroll.scroller,\n        scrollBehaviorX = _b.scrollBehaviorX,\n        scrollBehaviorY = _b.scrollBehaviorY; // enlarge boundaries manually when zoom is end\n\n    this.resetBoundaries([scrollBehaviorX, scrollBehaviorY]);\n    var xInBoundary = scrollBehaviorX.checkInBoundary().inBoundary;\n    var yInBoundary = scrollBehaviorX.checkInBoundary().inBoundary;\n    return !(xInBoundary && yInBoundary);\n  };\n\n  Zoom.prototype.dampingScale = function (scale) {\n    var _a = this.zoomOpt,\n        min = _a.min,\n        max = _a.max;\n\n    if (scale < min) {\n      scale = 0.5 * min * Math.pow(2.0, scale / min);\n    } else if (scale > max) {\n      scale = 2.0 * max * Math.pow(0.5, max / scale);\n    }\n\n    return scale;\n  };\n\n  Zoom.prototype.setScale = function (scale) {\n    this.scale = scale;\n  };\n\n  Zoom.prototype.resetBoundaries = function (scrollBehaviorPairs) {\n    scrollBehaviorPairs.forEach(function (behavior) {\n      return behavior.computeBoundary();\n    });\n  };\n\n  Zoom.prototype.getNewPos = function (origin, lastScale, scrollBehavior, shouldInBoundary, useCurrentPos) {\n    if (useCurrentPos === void 0) {\n      useCurrentPos = false;\n    }\n\n    var newPos = origin - origin * lastScale + (useCurrentPos ? scrollBehavior.currentPos : scrollBehavior.startPos);\n\n    if (shouldInBoundary) {\n      newPos = between(newPos, scrollBehavior.maxScrollPos, scrollBehavior.minScrollPos);\n    } // maxScrollPos or minScrollPos maybe a negative or positive digital\n\n\n    return newPos > 0 ? Math.floor(newPos) : Math.ceil(newPos);\n  };\n\n  Zoom.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  Zoom.prototype.destroy = function () {\n    this.hooksFn.forEach(function (item) {\n      var hooks = item[0];\n      var hooksName = item[1];\n      var handlerFn = item[2];\n      hooks.off(hooksName, handlerFn);\n    });\n    this.hooksFn.length = 0;\n  };\n\n  Zoom.pluginName = 'zoom';\n  return Zoom;\n}();\n\nvar BScrollFamily =\n/** @class */\nfunction () {\n  function BScrollFamily(scroll) {\n    this.ancestors = [];\n    this.descendants = [];\n    this.hooksManager = [];\n    this.analyzed = false;\n    this.selfScroll = scroll;\n  }\n\n  BScrollFamily.create = function (scroll) {\n    return new BScrollFamily(scroll);\n  };\n\n  BScrollFamily.prototype.hasAncestors = function (bscrollFamily) {\n    var index = findIndex(this.ancestors, function (_a) {\n      var item = _a[0];\n      return item === bscrollFamily;\n    });\n    return index > -1;\n  };\n\n  BScrollFamily.prototype.hasDescendants = function (bscrollFamily) {\n    var index = findIndex(this.descendants, function (_a) {\n      var item = _a[0];\n      return item === bscrollFamily;\n    });\n    return index > -1;\n  };\n\n  BScrollFamily.prototype.addAncestor = function (bscrollFamily, distance) {\n    var ancestors = this.ancestors;\n    ancestors.push([bscrollFamily, distance]); // by ascend\n\n    ancestors.sort(function (a, b) {\n      return a[1] - b[1];\n    });\n  };\n\n  BScrollFamily.prototype.addDescendant = function (bscrollFamily, distance) {\n    var descendants = this.descendants;\n    descendants.push([bscrollFamily, distance]); // by ascend\n\n    descendants.sort(function (a, b) {\n      return a[1] - b[1];\n    });\n  };\n\n  BScrollFamily.prototype.removeAncestor = function (bscrollFamily) {\n    var ancestors = this.ancestors;\n\n    if (ancestors.length) {\n      var index = findIndex(this.ancestors, function (_a) {\n        var item = _a[0];\n        return item === bscrollFamily;\n      });\n\n      if (index > -1) {\n        return ancestors.splice(index, 1);\n      }\n    }\n  };\n\n  BScrollFamily.prototype.removeDescendant = function (bscrollFamily) {\n    var descendants = this.descendants;\n\n    if (descendants.length) {\n      var index = findIndex(this.descendants, function (_a) {\n        var item = _a[0];\n        return item === bscrollFamily;\n      });\n\n      if (index > -1) {\n        return descendants.splice(index, 1);\n      }\n    }\n  };\n\n  BScrollFamily.prototype.registerHooks = function (hook, eventType, handler) {\n    hook.on(eventType, handler);\n    this.hooksManager.push([hook, eventType, handler]);\n  };\n\n  BScrollFamily.prototype.setAnalyzed = function (flag) {\n    if (flag === void 0) {\n      flag = false;\n    }\n\n    this.analyzed = flag;\n  };\n\n  BScrollFamily.prototype.purge = function () {\n    var _this = this; // remove self from graph\n\n\n    this.ancestors.forEach(function (_a) {\n      var bscrollFamily = _a[0];\n      bscrollFamily.removeDescendant(_this);\n    });\n    this.descendants.forEach(function (_a) {\n      var bscrollFamily = _a[0];\n      bscrollFamily.removeAncestor(_this);\n    }); // remove all hook handlers\n\n    this.hooksManager.forEach(function (_a) {\n      var hooks = _a[0],\n          eventType = _a[1],\n          handler = _a[2];\n      hooks.off(eventType, handler);\n    });\n    this.hooksManager = [];\n  };\n\n  return BScrollFamily;\n}();\n\nvar sourcePrefix$1 = 'plugins.nestedScroll';\nvar propertiesMap$1 = [{\n  key: 'purgeNestedScroll',\n  name: 'purgeNestedScroll'\n}];\nvar propertiesConfig$1 = propertiesMap$1.map(function (item) {\n  return {\n    key: item.key,\n    sourceKey: sourcePrefix$1 + \".\" + item.name\n  };\n});\nvar DEFAUL_GROUP_ID = 'INTERNAL_NESTED_SCROLL';\n\nvar forceScrollStopHandler = function (scrolls) {\n  scrolls.forEach(function (scroll) {\n    if (scroll.pending) {\n      scroll.stop();\n      scroll.resetPosition();\n    }\n  });\n};\n\nvar enableScrollHander = function (scrolls) {\n  scrolls.forEach(function (scroll) {\n    scroll.enable();\n  });\n};\n\nvar disableScrollHander = function (scrolls, currentScroll) {\n  scrolls.forEach(function (scroll) {\n    if (scroll.hasHorizontalScroll === currentScroll.hasHorizontalScroll || scroll.hasVerticalScroll === currentScroll.hasVerticalScroll) {\n      scroll.disable();\n    }\n  });\n};\n\nvar syncTouchstartData = function (scrolls) {\n  scrolls.forEach(function (scroll) {\n    var _a = scroll.scroller,\n        actions = _a.actions,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY; // prevent click triggering many times\n\n    actions.fingerMoved = true;\n    actions.contentMoved = false;\n    actions.directionLockAction.reset();\n    scrollBehaviorX.start();\n    scrollBehaviorY.start();\n    scrollBehaviorX.resetStartPos();\n    scrollBehaviorY.resetStartPos();\n    actions.startTime = +new Date();\n  });\n};\n\nvar isOutOfBoundary = function (scroll) {\n  var hasHorizontalScroll = scroll.hasHorizontalScroll,\n      hasVerticalScroll = scroll.hasVerticalScroll,\n      x = scroll.x,\n      y = scroll.y,\n      minScrollX = scroll.minScrollX,\n      maxScrollX = scroll.maxScrollX,\n      minScrollY = scroll.minScrollY,\n      maxScrollY = scroll.maxScrollY,\n      movingDirectionX = scroll.movingDirectionX,\n      movingDirectionY = scroll.movingDirectionY;\n  var ret = false;\n  var outOfLeftBoundary = x >= minScrollX && movingDirectionX === -1\n  /* Negative */\n  ;\n  var outOfRightBoundary = x <= maxScrollX && movingDirectionX === 1\n  /* Positive */\n  ;\n  var outOfTopBoundary = y >= minScrollY && movingDirectionY === -1\n  /* Negative */\n  ;\n  var outOfBottomBoundary = y <= maxScrollY && movingDirectionY === 1\n  /* Positive */\n  ;\n\n  if (hasVerticalScroll) {\n    ret = outOfTopBoundary || outOfBottomBoundary;\n  } else if (hasHorizontalScroll) {\n    ret = outOfLeftBoundary || outOfRightBoundary;\n  }\n\n  return ret;\n};\n\nvar isResettingPosition = function (scroll) {\n  var hasHorizontalScroll = scroll.hasHorizontalScroll,\n      hasVerticalScroll = scroll.hasVerticalScroll,\n      x = scroll.x,\n      y = scroll.y,\n      minScrollX = scroll.minScrollX,\n      maxScrollX = scroll.maxScrollX,\n      minScrollY = scroll.minScrollY,\n      maxScrollY = scroll.maxScrollY;\n  var ret = false;\n  var outOfLeftBoundary = x > minScrollX;\n  var outOfRightBoundary = x < maxScrollX;\n  var outOfTopBoundary = y > minScrollY;\n  var outOfBottomBoundary = y < maxScrollY;\n\n  if (hasVerticalScroll) {\n    ret = outOfTopBoundary || outOfBottomBoundary;\n  } else if (hasHorizontalScroll) {\n    ret = outOfLeftBoundary || outOfRightBoundary;\n  }\n\n  return ret;\n};\n\nvar resetPositionHandler = function (scroll) {\n  scroll.scroller.reflow();\n  scroll.resetPosition(0\n  /* Immediately */\n  );\n};\n\nvar calculateDistance = function (childNode, parentNode) {\n  var distance = 0;\n  var parent = childNode.parentNode;\n\n  while (parent && parent !== parentNode) {\n    distance++;\n    parent = parent.parentNode;\n  }\n\n  return distance;\n};\n\nvar NestedScroll =\n/** @class */\nfunction () {\n  function NestedScroll(scroll) {\n    var groupId = this.handleOptions(scroll);\n    var instance = NestedScroll.instancesMap[groupId];\n\n    if (!instance) {\n      instance = NestedScroll.instancesMap[groupId] = this;\n      instance.store = [];\n      instance.hooksFn = [];\n    }\n\n    instance.init(scroll);\n    return instance;\n  }\n\n  NestedScroll.getAllNestedScrolls = function () {\n    var instancesMap = NestedScroll.instancesMap;\n    return Object.keys(instancesMap).map(function (key) {\n      return instancesMap[key];\n    });\n  };\n\n  NestedScroll.purgeAllNestedScrolls = function () {\n    var nestedScrolls = NestedScroll.getAllNestedScrolls();\n    nestedScrolls.forEach(function (ns) {\n      return ns.purgeNestedScroll();\n    });\n  };\n\n  NestedScroll.prototype.handleOptions = function (scroll) {\n    var userOptions = scroll.options.nestedScroll === true ? {} : scroll.options.nestedScroll;\n    var defaultOptions = {\n      groupId: DEFAUL_GROUP_ID\n    };\n    this.options = extend(defaultOptions, userOptions);\n    var groupIdType = typeof this.options.groupId;\n\n    if (groupIdType !== 'string' && groupIdType !== 'number') {\n      warn('groupId must be string or number for NestedScroll plugin');\n    }\n\n    return this.options.groupId;\n  };\n\n  NestedScroll.prototype.init = function (scroll) {\n    scroll.proxy(propertiesConfig$1);\n    this.addBScroll(scroll);\n    this.buildBScrollGraph();\n    this.analyzeBScrollGraph();\n    this.ensureEventInvokeSequence();\n    this.handleHooks(scroll);\n  };\n\n  NestedScroll.prototype.handleHooks = function (scroll) {\n    var _this = this;\n\n    this.registerHooks(scroll.hooks, scroll.hooks.eventTypes.destroy, function () {\n      _this.deleteScroll(scroll);\n    });\n  };\n\n  NestedScroll.prototype.deleteScroll = function (scroll) {\n    var wrapper = scroll.wrapper;\n    wrapper.isBScrollContainer = undefined;\n    var store = this.store;\n    var hooksFn = this.hooksFn;\n    var i = findIndex(store, function (bscrollFamily) {\n      return bscrollFamily.selfScroll === scroll;\n    });\n\n    if (i > -1) {\n      var bscrollFamily = store[i];\n      bscrollFamily.purge();\n      store.splice(i, 1);\n    }\n\n    var k = findIndex(hooksFn, function (_a) {\n      var hooks = _a[0];\n      return hooks === scroll.hooks;\n    });\n\n    if (k > -1) {\n      var _a = hooksFn[k],\n          hooks = _a[0],\n          eventType = _a[1],\n          handler = _a[2];\n      hooks.off(eventType, handler);\n      hooksFn.splice(k, 1);\n    }\n  };\n\n  NestedScroll.prototype.addBScroll = function (scroll) {\n    this.store.push(BScrollFamily.create(scroll));\n  };\n\n  NestedScroll.prototype.buildBScrollGraph = function () {\n    var store = this.store;\n    var bf1;\n    var bf2;\n    var wrapper1;\n    var wrapper2;\n    var len = this.store.length; // build graph\n\n    for (var i = 0; i < len; i++) {\n      bf1 = store[i];\n      wrapper1 = bf1.selfScroll.wrapper;\n\n      for (var j = 0; j < len; j++) {\n        bf2 = store[j];\n        wrapper2 = bf2.selfScroll.wrapper; // same bs\n\n        if (bf1 === bf2) continue;\n        if (!wrapper1.contains(wrapper2)) continue; // bs1 contains bs2\n\n        var distance = calculateDistance(wrapper2, wrapper1);\n\n        if (!bf1.hasDescendants(bf2)) {\n          bf1.addDescendant(bf2, distance);\n        }\n\n        if (!bf2.hasAncestors(bf1)) {\n          bf2.addAncestor(bf1, distance);\n        }\n      }\n    }\n  };\n\n  NestedScroll.prototype.analyzeBScrollGraph = function () {\n    this.store.forEach(function (bscrollFamily) {\n      if (bscrollFamily.analyzed) {\n        return;\n      }\n\n      var ancestors = bscrollFamily.ancestors,\n          descendants = bscrollFamily.descendants,\n          currentScroll = bscrollFamily.selfScroll;\n\n      var beforeScrollStartHandler = function () {\n        // always get the latest scroll\n        var ancestorScrolls = ancestors.map(function (_a) {\n          var bscrollFamily = _a[0];\n          return bscrollFamily.selfScroll;\n        });\n        var descendantScrolls = descendants.map(function (_a) {\n          var bscrollFamily = _a[0];\n          return bscrollFamily.selfScroll;\n        });\n        forceScrollStopHandler(__spreadArrays(ancestorScrolls, descendantScrolls));\n\n        if (isResettingPosition(currentScroll)) {\n          resetPositionHandler(currentScroll);\n        }\n\n        syncTouchstartData(ancestorScrolls);\n        disableScrollHander(ancestorScrolls, currentScroll);\n      };\n\n      var touchEndHandler = function () {\n        var ancestorScrolls = ancestors.map(function (_a) {\n          var bscrollFamily = _a[0];\n          return bscrollFamily.selfScroll;\n        });\n        var descendantScrolls = descendants.map(function (_a) {\n          var bscrollFamily = _a[0];\n          return bscrollFamily.selfScroll;\n        });\n        enableScrollHander(__spreadArrays(ancestorScrolls, descendantScrolls));\n      };\n\n      bscrollFamily.registerHooks(currentScroll, currentScroll.eventTypes.beforeScrollStart, beforeScrollStartHandler);\n      bscrollFamily.registerHooks(currentScroll, currentScroll.eventTypes.touchEnd, touchEndHandler);\n      var selfActionsHooks = currentScroll.scroller.actions.hooks;\n      bscrollFamily.registerHooks(selfActionsHooks, selfActionsHooks.eventTypes.detectMovingDirection, function () {\n        var ancestorScrolls = ancestors.map(function (_a) {\n          var bscrollFamily = _a[0];\n          return bscrollFamily.selfScroll;\n        });\n        var parentScroll = ancestorScrolls[0];\n        var otherAncestorScrolls = ancestorScrolls.slice(1);\n        var contentMoved = currentScroll.scroller.actions.contentMoved;\n        var isTopScroll = ancestorScrolls.length === 0;\n\n        if (contentMoved) {\n          disableScrollHander(ancestorScrolls, currentScroll);\n        } else if (!isTopScroll) {\n          if (isOutOfBoundary(currentScroll)) {\n            disableScrollHander([currentScroll], currentScroll);\n\n            if (parentScroll) {\n              enableScrollHander([parentScroll]);\n            }\n\n            disableScrollHander(otherAncestorScrolls, currentScroll);\n            return true;\n          }\n        }\n      });\n      bscrollFamily.setAnalyzed(true);\n    });\n  }; // make sure touchmove|touchend invoke from child to parent\n\n\n  NestedScroll.prototype.ensureEventInvokeSequence = function () {\n    var copied = this.store.slice();\n    var sequencedScroll = copied.sort(function (a, b) {\n      return a.descendants.length - b.descendants.length;\n    });\n    sequencedScroll.forEach(function (bscrollFamily) {\n      var scroll = bscrollFamily.selfScroll;\n      scroll.scroller.actionsHandler.rebindDOMEvents();\n    });\n  };\n\n  NestedScroll.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  NestedScroll.prototype.purgeNestedScroll = function () {\n    var groupId = this.options.groupId;\n    this.store.forEach(function (bscrollFamily) {\n      bscrollFamily.purge();\n    });\n    this.store = [];\n    this.hooksFn.forEach(function (_a) {\n      var hooks = _a[0],\n          eventType = _a[1],\n          handler = _a[2];\n      hooks.off(eventType, handler);\n    });\n    this.hooksFn = [];\n    delete NestedScroll.instancesMap[groupId];\n  };\n\n  NestedScroll.pluginName = 'nestedScroll';\n  NestedScroll.instancesMap = {};\n  return NestedScroll;\n}();\n\nvar PRE_NUM = 10;\nvar POST_NUM = 30;\n\nvar IndexCalculator =\n/** @class */\nfunction () {\n  function IndexCalculator(wrapperHeight, tombstoneHeight) {\n    this.wrapperHeight = wrapperHeight;\n    this.tombstoneHeight = tombstoneHeight;\n    this.lastDirection = 1\n    /* DOWN */\n    ;\n    this.lastPos = 0;\n  }\n\n  IndexCalculator.prototype.calculate = function (pos, list) {\n    var offset = pos - this.lastPos;\n    this.lastPos = pos;\n    var direction = this.getDirection(offset); // important! start index is much more important than end index.\n\n    var start = this.calculateIndex(0, pos, list);\n    var end = this.calculateIndex(start, pos + this.wrapperHeight, list);\n\n    if (direction === 1\n    /* DOWN */\n    ) {\n      start -= PRE_NUM;\n      end += POST_NUM;\n    } else {\n      start -= POST_NUM;\n      end += PRE_NUM;\n    }\n\n    if (start < 0) {\n      start = 0;\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  IndexCalculator.prototype.getDirection = function (offset) {\n    var direction;\n\n    if (offset > 0) {\n      direction = 1\n      /* DOWN */\n      ;\n    } else if (offset < 0) {\n      direction = 0\n      /* UP */\n      ;\n    } else {\n      return this.lastDirection;\n    }\n\n    this.lastDirection = direction;\n    return direction;\n  };\n\n  IndexCalculator.prototype.calculateIndex = function (start, offset, list) {\n    if (offset <= 0) {\n      return start;\n    }\n\n    var i = start;\n    var startPos = list[i] && list[i].pos !== -1 ? list[i].pos : 0;\n    var lastPos = startPos;\n    var tombstone = 0;\n\n    while (i < list.length && list[i].pos < offset) {\n      lastPos = list[i].pos;\n      i++;\n    }\n\n    if (i === list.length) {\n      tombstone = Math.floor((offset - lastPos) / this.tombstoneHeight);\n    }\n\n    i += tombstone;\n    return i;\n  };\n\n  IndexCalculator.prototype.resetState = function () {\n    this.lastDirection = 1\n    /* DOWN */\n    ;\n    this.lastPos = 0;\n  };\n\n  return IndexCalculator;\n}();\n\nvar ListItem =\n/** @class */\nfunction () {\n  function ListItem() {\n    this.data = null;\n    this.dom = null;\n    this.tombstone = null;\n    this.width = 0;\n    this.height = 0;\n    this.pos = 0;\n  }\n\n  return ListItem;\n}();\n\nvar DataManager =\n/** @class */\nfunction () {\n  function DataManager(list, fetchFn, onFetchFinish) {\n    this.fetchFn = fetchFn;\n    this.onFetchFinish = onFetchFinish;\n    this.loadedNum = 0;\n    this.fetching = false;\n    this.hasMore = true;\n    this.list = list || [];\n  }\n\n  DataManager.prototype.update = function (end) {\n    return __awaiter(this, void 0, void 0, function () {\n      var len;\n      return __generator(this, function (_a) {\n        if (!this.hasMore) {\n          end = Math.min(end, this.list.length);\n        } // add data placeholder\n\n\n        if (end > this.list.length) {\n          len = end - this.list.length;\n          this.addEmptyData(len);\n        } // tslint:disable-next-line: no-floating-promises\n\n\n        return [2\n        /*return*/\n        , this.checkToFetch(end)];\n      });\n    });\n  };\n\n  DataManager.prototype.add = function (data) {\n    for (var i = 0; i < data.length; i++) {\n      if (!this.list[this.loadedNum]) {\n        this.list[this.loadedNum] = {\n          data: data[i]\n        };\n      } else {\n        this.list[this.loadedNum] = __assign(__assign({}, this.list[this.loadedNum]), {\n          data: data[i]\n        });\n      }\n\n      this.loadedNum++;\n    }\n\n    return this.list;\n  };\n\n  DataManager.prototype.addEmptyData = function (len) {\n    for (var i = 0; i < len; i++) {\n      this.list.push(new ListItem());\n    }\n\n    return this.list;\n  };\n\n  DataManager.prototype.fetch = function (len) {\n    return __awaiter(this, void 0, void 0, function () {\n      var data;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.fetching) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            this.fetching = true;\n            return [4\n            /*yield*/\n            , this.fetchFn(len)];\n\n          case 1:\n            data = _a.sent();\n            this.fetching = false;\n            return [2\n            /*return*/\n            , data];\n        }\n      });\n    });\n  };\n\n  DataManager.prototype.checkToFetch = function (end) {\n    return __awaiter(this, void 0, void 0, function () {\n      var min, newData, currentEnd;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.hasMore) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (end <= this.loadedNum) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            min = end - this.loadedNum;\n            return [4\n            /*yield*/\n            , this.fetch(min)];\n\n          case 1:\n            newData = _a.sent();\n\n            if (newData instanceof Array && newData.length) {\n              this.add(newData);\n              currentEnd = this.onFetchFinish(this.list, true);\n              return [2\n              /*return*/\n              , this.checkToFetch(currentEnd)];\n            } else if (typeof newData === 'boolean' && newData === false) {\n              this.hasMore = false;\n              this.list.splice(this.loadedNum);\n              this.onFetchFinish(this.list, false);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DataManager.prototype.getList = function () {\n    return this.list;\n  };\n\n  DataManager.prototype.resetState = function () {\n    this.loadedNum = 0;\n    this.fetching = false;\n    this.hasMore = true;\n    this.list = [];\n  };\n\n  return DataManager;\n}();\n\nvar Tombstone =\n/** @class */\nfunction () {\n  function Tombstone(create) {\n    this.create = create;\n    this.cached = [];\n    this.width = 0;\n    this.height = 0;\n    this.initialed = false;\n    this.getSize();\n  }\n\n  Tombstone.isTombstone = function (el) {\n    if (el && el.classList) {\n      return el.classList.contains('tombstone');\n    }\n\n    return false;\n  };\n\n  Tombstone.prototype.getSize = function () {\n    if (!this.initialed) {\n      var tombstone = this.create();\n      tombstone.style.position = 'absolute';\n      document.body.appendChild(tombstone);\n      tombstone.style.display = '';\n      this.height = tombstone.offsetHeight;\n      this.width = tombstone.offsetWidth;\n      document.body.removeChild(tombstone);\n      this.cached.push(tombstone);\n    }\n  };\n\n  Tombstone.prototype.getOne = function () {\n    var tombstone = this.cached.pop();\n\n    if (tombstone) {\n      var tombstoneStyle = tombstone.style;\n      tombstoneStyle.display = '';\n      tombstoneStyle.opacity = '1';\n      tombstoneStyle[style.transform] = '';\n      tombstoneStyle[style.transition] = '';\n      return tombstone;\n    }\n\n    return this.create();\n  };\n\n  Tombstone.prototype.recycle = function (tombstones) {\n    for (var _i = 0, tombstones_1 = tombstones; _i < tombstones_1.length; _i++) {\n      var tombstone = tombstones_1[_i];\n      tombstone.style.display = 'none';\n      this.cached.push(tombstone);\n    }\n\n    return this.cached;\n  };\n\n  Tombstone.prototype.recycleOne = function (tombstone) {\n    this.cached.push(tombstone);\n    return this.cached;\n  };\n\n  return Tombstone;\n}();\n\nvar ANIMATION_DURATION_MS = 200;\n\nvar DomManager =\n/** @class */\nfunction () {\n  function DomManager(content, renderFn, tombstone) {\n    this.renderFn = renderFn;\n    this.tombstone = tombstone;\n    this.unusedDom = [];\n    this.timers = [];\n    this.setContent(content);\n  }\n\n  DomManager.prototype.update = function (list, start, end) {\n    if (start >= list.length) {\n      start = list.length - 1;\n    }\n\n    if (end > list.length) {\n      end = list.length;\n    }\n\n    this.collectUnusedDom(list, start, end);\n    this.createDom(list, start, end);\n    this.cacheHeight(list, start, end);\n\n    var _a = this.positionDom(list, start, end),\n        startPos = _a.startPos,\n        startDelta = _a.startDelta,\n        endPos = _a.endPos;\n\n    return {\n      start: start,\n      startPos: startPos,\n      startDelta: startDelta,\n      end: end,\n      endPos: endPos\n    };\n  };\n\n  DomManager.prototype.collectUnusedDom = function (list, start, end) {\n    // TODO optimise\n    for (var i = 0; i < list.length; i++) {\n      if (i === start) {\n        i = end - 1;\n        continue;\n      }\n\n      if (list[i].dom) {\n        var dom = list[i].dom;\n\n        if (Tombstone.isTombstone(dom)) {\n          this.tombstone.recycleOne(dom);\n          dom.style.display = 'none';\n        } else {\n          this.unusedDom.push(dom);\n        }\n\n        list[i].dom = null;\n      }\n    }\n\n    return list;\n  };\n\n  DomManager.prototype.createDom = function (list, start, end) {\n    for (var i = start; i < end; i++) {\n      var dom = list[i].dom;\n      var data = list[i].data;\n\n      if (dom) {\n        if (Tombstone.isTombstone(dom) && data) {\n          list[i].tombstone = dom;\n          list[i].dom = null;\n        } else {\n          continue;\n        }\n      }\n\n      dom = data ? this.renderFn(data, this.unusedDom.pop()) : this.tombstone.getOne();\n      dom.style.position = 'absolute';\n      list[i].dom = dom;\n      list[i].pos = -1;\n      this.content.appendChild(dom);\n    }\n  };\n\n  DomManager.prototype.cacheHeight = function (list, start, end) {\n    for (var i = start; i < end; i++) {\n      if (list[i].data && !list[i].height) {\n        list[i].height = list[i].dom.offsetHeight;\n      }\n    }\n  };\n\n  DomManager.prototype.positionDom = function (list, start, end) {\n    var _this = this;\n\n    var tombstoneEles = [];\n\n    var _a = this.getStartPos(list, start, end),\n        startPos = _a.start,\n        startDelta = _a.delta;\n\n    var pos = startPos;\n\n    for (var i = start; i < end; i++) {\n      var tombstone = list[i].tombstone;\n\n      if (tombstone) {\n        var tombstoneStyle = tombstone.style;\n        tombstoneStyle[style.transition] = cssVendor + \"transform \" + ANIMATION_DURATION_MS + \"ms, opacity \" + ANIMATION_DURATION_MS + \"ms\";\n        tombstoneStyle[style.transform] = \"translateY(\" + pos + \"px)\";\n        tombstoneStyle.opacity = '0';\n        list[i].tombstone = null;\n        tombstoneEles.push(tombstone);\n      }\n\n      if (list[i].dom && list[i].pos !== pos) {\n        list[i].dom.style[style.transform] = \"translateY(\" + pos + \"px)\";\n        list[i].pos = pos;\n      }\n\n      pos += list[i].height || this.tombstone.height;\n    }\n\n    var timerId = window.setTimeout(function () {\n      _this.tombstone.recycle(tombstoneEles);\n    }, ANIMATION_DURATION_MS);\n    this.timers.push(timerId);\n    return {\n      startPos: startPos,\n      startDelta: startDelta,\n      endPos: pos\n    };\n  };\n\n  DomManager.prototype.getStartPos = function (list, start, end) {\n    if (list[start] && list[start].pos !== -1) {\n      return {\n        start: list[start].pos,\n        delta: 0\n      };\n    } // TODO optimise\n\n\n    var pos = list[0].pos === -1 ? 0 : list[0].pos;\n\n    for (var i_1 = 0; i_1 < start; i_1++) {\n      pos += list[i_1].height || this.tombstone.height;\n    }\n\n    var originPos = pos;\n    var i;\n\n    for (i = start; i < end; i++) {\n      if (!Tombstone.isTombstone(list[i].dom) && list[i].pos !== -1) {\n        pos = list[i].pos;\n        break;\n      }\n    }\n\n    var x = i;\n\n    if (x < end) {\n      while (x > start) {\n        pos -= list[x - 1].height;\n        x--;\n      }\n    }\n\n    var delta = originPos - pos;\n    return {\n      start: pos,\n      delta: delta\n    };\n  };\n\n  DomManager.prototype.removeTombstone = function () {\n    var tombstones = this.content.querySelectorAll('.tombstone');\n\n    for (var i = tombstones.length - 1; i >= 0; i--) {\n      this.content.removeChild(tombstones[i]);\n    }\n  };\n\n  DomManager.prototype.setContent = function (content) {\n    if (content !== this.content) {\n      this.content = content;\n    }\n  };\n\n  DomManager.prototype.destroy = function () {\n    this.removeTombstone();\n    this.timers.forEach(function (id) {\n      clearTimeout(id);\n    });\n  };\n\n  DomManager.prototype.resetState = function () {\n    this.destroy();\n    this.timers = [];\n    this.unusedDom = [];\n  };\n\n  return DomManager;\n}();\n\nvar EXTRA_SCROLL_Y = -2000;\n\nvar InfinityScroll =\n/** @class */\nfunction () {\n  function InfinityScroll(scroll) {\n    this.scroll = scroll;\n    this.start = 0;\n    this.end = 0;\n    this.init();\n  }\n\n  InfinityScroll.prototype.init = function () {\n    var _this = this;\n\n    this.handleOptions();\n    var _a = this.options,\n        fetchFn = _a.fetch,\n        renderFn = _a.render,\n        createTombstoneFn = _a.createTombstone;\n    this.tombstone = new Tombstone(createTombstoneFn);\n    this.indexCalculator = new IndexCalculator(this.scroll.scroller.scrollBehaviorY.wrapperSize, this.tombstone.height);\n    this.domManager = new DomManager(this.scroll.scroller.content, renderFn, this.tombstone);\n    this.dataManager = new DataManager([], fetchFn, this.onFetchFinish.bind(this));\n    this.scroll.on(this.scroll.eventTypes.destroy, this.destroy, this);\n    this.scroll.on(this.scroll.eventTypes.scroll, this.update, this);\n    this.scroll.on(this.scroll.eventTypes.contentChanged, function (content) {\n      _this.domManager.setContent(content);\n\n      _this.indexCalculator.resetState();\n\n      _this.domManager.resetState();\n\n      _this.dataManager.resetState();\n\n      _this.update({\n        y: 0\n      });\n    });\n    var scrollBehaviorY = this.scroll.scroller.scrollBehaviorY;\n    scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.computeBoundary, this.modifyBoundary, this);\n    this.update({\n      y: 0\n    });\n  };\n\n  InfinityScroll.prototype.modifyBoundary = function (boundary) {\n    // manually set position to allow scroll\n    boundary.maxScrollPos = EXTRA_SCROLL_Y;\n  };\n\n  InfinityScroll.prototype.handleOptions = function () {\n    // narrow down type to an object\n    var infinityOptions = this.scroll.options.infinity;\n\n    if (infinityOptions) {\n      if (typeof infinityOptions.fetch !== 'function') {\n        warn('Infinity plugin need fetch Function to new data.');\n      }\n\n      if (typeof infinityOptions.render !== 'function') {\n        warn('Infinity plugin need render Function to render each item.');\n      }\n\n      if (typeof infinityOptions.render !== 'function') {\n        warn('Infinity plugin need createTombstone Function to create tombstone.');\n      }\n\n      this.options = infinityOptions;\n    }\n\n    this.scroll.options.probeType = 3\n    /* Realtime */\n    ;\n  };\n\n  InfinityScroll.prototype.update = function (pos) {\n    var position = Math.round(-pos.y); // important! calculate start/end index to render\n\n    var _a = this.indexCalculator.calculate(position, this.dataManager.getList()),\n        start = _a.start,\n        end = _a.end;\n\n    this.start = start;\n    this.end = end; // tslint:disable-next-line: no-floating-promises\n\n    this.dataManager.update(end);\n    this.updateDom(this.dataManager.getList());\n  };\n\n  InfinityScroll.prototype.onFetchFinish = function (list, hasMore) {\n    var end = this.updateDom(list).end;\n\n    if (!hasMore) {\n      this.domManager.removeTombstone();\n      this.scroll.scroller.animater.stop();\n      this.scroll.resetPosition();\n    } // tslint:disable-next-line: no-floating-promises\n\n\n    return end;\n  };\n\n  InfinityScroll.prototype.updateDom = function (list) {\n    var _a = this.domManager.update(list, this.start, this.end),\n        end = _a.end,\n        startPos = _a.startPos,\n        endPos = _a.endPos,\n        startDelta = _a.startDelta;\n\n    if (startDelta) {\n      this.scroll.minScrollY = startDelta;\n    }\n\n    if (endPos > this.scroll.maxScrollY) {\n      this.scroll.maxScrollY = -(endPos - this.scroll.scroller.scrollBehaviorY.wrapperSize);\n    }\n\n    return {\n      end: end,\n      startPos: startPos,\n      endPos: endPos\n    };\n  };\n\n  InfinityScroll.prototype.destroy = function () {\n    var _a = this.scroll.scroller,\n        content = _a.content,\n        scrollBehaviorY = _a.scrollBehaviorY;\n\n    while (content.firstChild) {\n      content.removeChild(content.firstChild);\n    }\n\n    this.domManager.destroy();\n    this.scroll.off('scroll', this.update);\n    this.scroll.off('destroy', this.destroy);\n    scrollBehaviorY.hooks.off(scrollBehaviorY.hooks.eventTypes.computeBoundary);\n  };\n\n  InfinityScroll.pluginName = 'infinity';\n  return InfinityScroll;\n}();\n\nvar sourcePrefix = 'plugins.movable';\nvar propertiesMap = [{\n  key: 'putAt',\n  name: 'putAt'\n}];\nvar propertiesConfig = propertiesMap.map(function (item) {\n  return {\n    key: item.key,\n    sourceKey: sourcePrefix + \".\" + item.name\n  };\n});\n\nvar Movable =\n/** @class */\nfunction () {\n  function Movable(scroll) {\n    this.scroll = scroll;\n    this.handleBScroll();\n    this.handleHooks();\n  }\n\n  Movable.prototype.handleBScroll = function () {\n    this.scroll.proxy(propertiesConfig);\n  };\n\n  Movable.prototype.handleHooks = function () {\n    var _this = this;\n\n    this.hooksFn = [];\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n\n    var computeBoundary = function (boundary, behavior) {\n      if (boundary.maxScrollPos > 0) {\n        // content is smaller than wrapper\n        boundary.minScrollPos = behavior.wrapperSize - behavior.contentSize;\n        boundary.maxScrollPos = 0;\n      }\n    };\n\n    this.registerHooks(scrollBehaviorX.hooks, scrollBehaviorX.hooks.eventTypes.ignoreHasScroll, function () {\n      return true;\n    });\n    this.registerHooks(scrollBehaviorX.hooks, scrollBehaviorX.hooks.eventTypes.computeBoundary, function (boundary) {\n      computeBoundary(boundary, scrollBehaviorX);\n    });\n    this.registerHooks(scrollBehaviorY.hooks, scrollBehaviorY.hooks.eventTypes.ignoreHasScroll, function () {\n      return true;\n    });\n    this.registerHooks(scrollBehaviorY.hooks, scrollBehaviorY.hooks.eventTypes.computeBoundary, function (boundary) {\n      computeBoundary(boundary, scrollBehaviorY);\n    });\n    this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.destroy, function () {\n      _this.destroy();\n    });\n  };\n\n  Movable.prototype.putAt = function (x, y, time, easing) {\n    if (time === void 0) {\n      time = this.scroll.options.bounceTime;\n    }\n\n    if (easing === void 0) {\n      easing = ease.bounce;\n    }\n\n    var position = this.resolvePostion(x, y);\n    this.scroll.scrollTo(position.x, position.y, time, easing);\n  };\n\n  Movable.prototype.resolvePostion = function (x, y) {\n    var _a = this.scroll.scroller,\n        scrollBehaviorX = _a.scrollBehaviorX,\n        scrollBehaviorY = _a.scrollBehaviorY;\n    var resolveFormula = {\n      left: function () {\n        return 0;\n      },\n      top: function () {\n        return 0;\n      },\n      right: function () {\n        return scrollBehaviorX.minScrollPos;\n      },\n      bottom: function () {\n        return scrollBehaviorY.minScrollPos;\n      },\n      center: function (index) {\n        var baseSize = index === 0 ? scrollBehaviorX.minScrollPos : scrollBehaviorY.minScrollPos;\n        return baseSize / 2;\n      }\n    };\n    return {\n      x: typeof x === 'number' ? x : resolveFormula[x](0),\n      y: typeof y === 'number' ? y : resolveFormula[y](1)\n    };\n  };\n\n  Movable.prototype.destroy = function () {\n    this.hooksFn.forEach(function (item) {\n      var hooks = item[0];\n      var hooksName = item[1];\n      var handlerFn = item[2];\n      hooks.off(hooksName, handlerFn);\n    });\n    this.hooksFn.length = 0;\n  };\n\n  Movable.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  Movable.pluginName = 'movable';\n  Movable.applyOrder = \"pre\"\n  /* Pre */\n  ;\n  return Movable;\n}();\n\nvar isImageTag = function (el) {\n  return el.tagName.toLowerCase() === 'img';\n};\n\nvar ObserveImage =\n/** @class */\nfunction () {\n  function ObserveImage(scroll) {\n    this.scroll = scroll;\n    this.refreshTimer = 0;\n    this.init();\n  }\n\n  ObserveImage.prototype.init = function () {\n    this.handleOptions(this.scroll.options.observeImage);\n    this.bindEventsToWrapper();\n  };\n\n  ObserveImage.prototype.handleOptions = function (userOptions) {\n    if (userOptions === void 0) {\n      userOptions = {};\n    }\n\n    userOptions = userOptions === true ? {} : userOptions;\n    var defaultOptions = {\n      debounceTime: 100\n    };\n    this.options = extend(defaultOptions, userOptions);\n  };\n\n  ObserveImage.prototype.bindEventsToWrapper = function () {\n    var wrapper = this.scroll.scroller.wrapper;\n    this.imageLoadEventRegister = new EventRegister(wrapper, [{\n      name: 'load',\n      handler: this.load.bind(this),\n      capture: true\n    }]);\n    this.imageErrorEventRegister = new EventRegister(wrapper, [{\n      name: 'error',\n      handler: this.load.bind(this),\n      capture: true\n    }]);\n  };\n\n  ObserveImage.prototype.load = function (e) {\n    var _this = this;\n\n    var target = e.target;\n    var debounceTime = this.options.debounceTime;\n\n    if (target && isImageTag(target)) {\n      if (debounceTime === 0) {\n        this.scroll.refresh();\n      } else {\n        clearTimeout(this.refreshTimer);\n        this.refreshTimer = window.setTimeout(function () {\n          _this.scroll.refresh();\n        }, this.options.debounceTime);\n      }\n    }\n  };\n\n  ObserveImage.pluginName = 'observeImage';\n  return ObserveImage;\n}();\n\nvar resolveRatioOption = function (ratioConfig) {\n  var ret = {\n    ratioX: 0,\n    ratioY: 0\n  };\n  /* istanbul ignore if  */\n\n  if (!ratioConfig) {\n    return ret;\n  }\n\n  if (typeof ratioConfig === 'number') {\n    ret.ratioX = ret.ratioY = ratioConfig;\n  } else if (typeof ratioConfig === 'object' && ratioConfig) {\n    ret.ratioX = ratioConfig.x || 0;\n    ret.ratioY = ratioConfig.y || 0;\n  }\n\n  return ret;\n};\n\nvar handleBubbleAndCancelable = function (e) {\n  maybePrevent(e);\n  e.stopPropagation();\n};\n\nvar Indicator =\n/** @class */\nfunction () {\n  function Indicator(scroll, options) {\n    this.scroll = scroll;\n    this.options = options;\n    this.currentPos = {\n      x: 0,\n      y: 0\n    };\n    this.hooksFn = [];\n    this.handleDOM();\n    this.handleHooks();\n    this.handleInteractive();\n  }\n\n  Indicator.prototype.handleDOM = function () {\n    var _a = this.options,\n        relationElement = _a.relationElement,\n        _b = _a.relationElementHandleElementIndex,\n        relationElementHandleElementIndex = _b === void 0 ? 0 : _b;\n    this.wrapper = relationElement;\n    this.indicatorEl = this.wrapper.children[relationElementHandleElementIndex];\n  };\n\n  Indicator.prototype.handleHooks = function () {\n    var _this = this;\n\n    var scroll = this.scroll;\n    var scrollHooks = scroll.hooks;\n    var translaterHooks = scroll.scroller.translater.hooks;\n    var animaterHooks = scroll.scroller.animater.hooks;\n    this.registerHooks(scrollHooks, scrollHooks.eventTypes.refresh, this.refresh);\n    this.registerHooks(translaterHooks, translaterHooks.eventTypes.translate, function (pos) {\n      _this.updatePosition(pos);\n    });\n    this.registerHooks(animaterHooks, animaterHooks.eventTypes.time, this.transitionTime);\n    this.registerHooks(animaterHooks, animaterHooks.eventTypes.timeFunction, this.transitionTimingFunction);\n  };\n\n  Indicator.prototype.transitionTime = function (time) {\n    if (time === void 0) {\n      time = 0;\n    }\n\n    this.indicatorEl.style[style.transitionDuration] = time + 'ms';\n  };\n\n  Indicator.prototype.transitionTimingFunction = function (easing) {\n    this.indicatorEl.style[style.transitionTimingFunction] = easing;\n  };\n\n  Indicator.prototype.handleInteractive = function () {\n    if (this.options.interactive !== false) {\n      this.registerEvents();\n    }\n  };\n\n  Indicator.prototype.registerHooks = function (hooks, name, handler) {\n    hooks.on(name, handler, this);\n    this.hooksFn.push([hooks, name, handler]);\n  };\n\n  Indicator.prototype.registerEvents = function () {\n    var _a = this.scroll.options,\n        disableMouse = _a.disableMouse,\n        disableTouch = _a.disableTouch;\n    var startEvents = [];\n    var moveEvents = [];\n    var endEvents = [];\n\n    if (!disableMouse) {\n      startEvents.push({\n        name: 'mousedown',\n        handler: this.start.bind(this)\n      });\n      moveEvents.push({\n        name: 'mousemove',\n        handler: this.move.bind(this)\n      });\n      endEvents.push({\n        name: 'mouseup',\n        handler: this.end.bind(this)\n      });\n    }\n\n    if (!disableTouch) {\n      startEvents.push({\n        name: 'touchstart',\n        handler: this.start.bind(this)\n      });\n      moveEvents.push({\n        name: 'touchmove',\n        handler: this.move.bind(this)\n      });\n      endEvents.push({\n        name: 'touchend',\n        handler: this.end.bind(this)\n      }, {\n        name: 'touchcancel',\n        handler: this.end.bind(this)\n      });\n    }\n\n    this.startEventRegister = new EventRegister(this.indicatorEl, startEvents);\n    this.moveEventRegister = new EventRegister(window, moveEvents);\n    this.endEventRegister = new EventRegister(window, endEvents);\n  };\n\n  Indicator.prototype.refresh = function () {\n    var _a = this.scroll,\n        x = _a.x,\n        y = _a.y,\n        hasHorizontalScroll = _a.hasHorizontalScroll,\n        hasVerticalScroll = _a.hasVerticalScroll,\n        maxBScrollX = _a.maxScrollX,\n        maxBScrollY = _a.maxScrollY;\n\n    var _b = resolveRatioOption(this.options.ratio),\n        ratioX = _b.ratioX,\n        ratioY = _b.ratioY;\n\n    var _c = getClientSize(this.wrapper),\n        wrapperWidth = _c.width,\n        wrapperHeight = _c.height;\n\n    var _d = getRect(this.indicatorEl),\n        indicatorWidth = _d.width,\n        indicatorHeight = _d.height;\n\n    if (hasHorizontalScroll) {\n      this.maxScrollX = wrapperWidth - indicatorWidth;\n      this.translateXSign = this.maxScrollX > 0 ? -1\n      /* Positive */\n      : 1\n      /* NotPositive */\n      ;\n      this.minScrollX = 0; // ensure positive\n\n      this.ratioX = ratioX ? ratioX : Math.abs(this.maxScrollX / maxBScrollX);\n    }\n\n    if (hasVerticalScroll) {\n      this.maxScrollY = wrapperHeight - indicatorHeight;\n      this.translateYSign = this.maxScrollY > 0 ? -1\n      /* Positive */\n      : 1\n      /* NotPositive */\n      ;\n      this.minScrollY = 0;\n      this.ratioY = ratioY ? ratioY : Math.abs(this.maxScrollY / maxBScrollY);\n    }\n\n    this.updatePosition({\n      x: x,\n      y: y\n    });\n  };\n\n  Indicator.prototype.start = function (e) {\n    if (this.BScrollIsDisabled()) {\n      return;\n    }\n\n    var point = e.touches ? e.touches[0] : e;\n    handleBubbleAndCancelable(e);\n    this.initiated = true;\n    this.moved = false;\n    this.lastPointX = point.pageX;\n    this.lastPointY = point.pageY;\n    this.startTime = getNow();\n    this.scroll.scroller.hooks.trigger(this.scroll.scroller.hooks.eventTypes.beforeScrollStart);\n  };\n\n  Indicator.prototype.BScrollIsDisabled = function () {\n    return !this.scroll.enabled;\n  };\n\n  Indicator.prototype.move = function (e) {\n    if (!this.initiated) {\n      return;\n    }\n\n    var point = e.touches ? e.touches[0] : e;\n    var pointX = point.pageX;\n    var pointY = point.pageY;\n    handleBubbleAndCancelable(e);\n    var deltaX = pointX - this.lastPointX;\n    var deltaY = pointY - this.lastPointY;\n    this.lastPointX = pointX;\n    this.lastPointY = pointY;\n\n    if (!this.moved && !this.indicatorNotMoved(deltaX, deltaY)) {\n      this.moved = true;\n      this.scroll.scroller.hooks.trigger(this.scroll.scroller.hooks.eventTypes.scrollStart);\n    }\n\n    if (this.moved) {\n      var newPos = this.getBScrollPosByRatio(this.currentPos, deltaX, deltaY);\n      this.syncBScroll(newPos);\n    }\n  };\n\n  Indicator.prototype.end = function (e) {\n    if (!this.initiated) {\n      return;\n    }\n\n    this.initiated = false;\n    handleBubbleAndCancelable(e);\n\n    if (this.moved) {\n      var _a = this.scroll,\n          x = _a.x,\n          y = _a.y;\n      this.scroll.scroller.hooks.trigger(this.scroll.scroller.hooks.eventTypes.scrollEnd, {\n        x: x,\n        y: y\n      });\n    }\n  };\n\n  Indicator.prototype.getBScrollPosByRatio = function (currentPos, deltaX, deltaY) {\n    var currentX = currentPos.x,\n        currentY = currentPos.y;\n    var _a = this.scroll,\n        hasHorizontalScroll = _a.hasHorizontalScroll,\n        hasVerticalScroll = _a.hasVerticalScroll,\n        BScrollMinScrollX = _a.minScrollX,\n        BScrollMaxScrollX = _a.maxScrollX,\n        BScrollMinScrollY = _a.minScrollY,\n        BScrollMaxScrollY = _a.maxScrollY;\n    var _b = this.scroll,\n        x = _b.x,\n        y = _b.y;\n\n    if (hasHorizontalScroll) {\n      var newPosX = between(currentX + deltaX, Math.min(this.minScrollX, this.maxScrollX), Math.max(this.minScrollX, this.maxScrollX));\n      var roundX = Math.round(newPosX / this.ratioX * this.translateXSign);\n      x = between(roundX, BScrollMaxScrollX, BScrollMinScrollX);\n    }\n\n    if (hasVerticalScroll) {\n      var newPosY = between(currentY + deltaY, Math.min(this.minScrollY, this.maxScrollY), Math.max(this.minScrollY, this.maxScrollY));\n      var roundY = Math.round(newPosY / this.ratioY * this.translateYSign);\n      y = between(roundY, BScrollMaxScrollY, BScrollMinScrollY);\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  Indicator.prototype.indicatorNotMoved = function (deltaX, deltaY) {\n    var _a = this.currentPos,\n        x = _a.x,\n        y = _a.y;\n    var xNotMoved = x === this.minScrollX && deltaX <= 0 || x === this.maxScrollX && deltaX >= 0;\n    var yNotMoved = y === this.minScrollY && deltaY <= 0 || y === this.maxScrollY && deltaY >= 0;\n    return xNotMoved && yNotMoved;\n  };\n\n  Indicator.prototype.syncBScroll = function (newPos) {\n    var timestamp = getNow();\n    var _a = this.scroll,\n        options = _a.options,\n        scroller = _a.scroller;\n    var probeType = options.probeType,\n        momentumLimitTime = options.momentumLimitTime;\n    scroller.translater.translate(newPos); // dispatch scroll in interval time\n\n    if (timestamp - this.startTime > momentumLimitTime) {\n      this.startTime = timestamp;\n\n      if (probeType === 1\n      /* Throttle */\n      ) {\n        scroller.hooks.trigger(scroller.hooks.eventTypes.scroll, newPos);\n      }\n    } // dispatch scroll all the time\n\n\n    if (probeType > 1\n    /* Throttle */\n    ) {\n      scroller.hooks.trigger(scroller.hooks.eventTypes.scroll, newPos);\n    }\n  };\n\n  Indicator.prototype.updatePosition = function (BScrollPos) {\n    var newIndicatorPos = this.getIndicatorPosByRatio(BScrollPos);\n    this.applyTransformProperty(newIndicatorPos);\n    this.currentPos = __assign({}, newIndicatorPos);\n  };\n\n  Indicator.prototype.applyTransformProperty = function (pos) {\n    var translateZ = this.scroll.options.translateZ;\n    var transformProperties = [\"translateX(\" + pos.x + \"px)\", \"translateY(\" + pos.y + \"px)\", \"\" + translateZ];\n    this.indicatorEl.style[style.transform] = transformProperties.join(' ');\n  };\n\n  Indicator.prototype.getIndicatorPosByRatio = function (BScrollPos) {\n    var x = BScrollPos.x,\n        y = BScrollPos.y;\n    var _a = this.scroll,\n        hasHorizontalScroll = _a.hasHorizontalScroll,\n        hasVerticalScroll = _a.hasVerticalScroll;\n\n    var position = __assign({}, this.currentPos);\n\n    if (hasHorizontalScroll) {\n      var roundX = Math.round(this.ratioX * x * this.translateXSign); // maybe maxScrollX is negative\n\n      position.x = between(roundX, Math.min(this.minScrollX, this.maxScrollX), Math.max(this.minScrollX, this.maxScrollX));\n    }\n\n    if (hasVerticalScroll) {\n      var roundY = Math.round(this.ratioY * y * this.translateYSign); // maybe maxScrollY is negative\n\n      position.y = between(roundY, Math.min(this.minScrollY, this.maxScrollY), Math.max(this.minScrollY, this.maxScrollY));\n    }\n\n    return position;\n  };\n\n  Indicator.prototype.destroy = function () {\n    if (this.options.interactive !== false) {\n      this.startEventRegister.destroy();\n      this.moveEventRegister.destroy();\n      this.endEventRegister.destroy();\n    }\n\n    this.hooksFn.forEach(function (item) {\n      var hooks = item[0];\n      var hooksName = item[1];\n      var handlerFn = item[2];\n      hooks.off(hooksName, handlerFn);\n    });\n    this.hooksFn.length = 0;\n  };\n\n  return Indicator;\n}();\n\nvar Indicators =\n/** @class */\nfunction () {\n  function Indicators(scroll) {\n    this.scroll = scroll;\n    this.options = [];\n    this.indicators = [];\n    this.handleOptions();\n    this.handleHooks();\n  }\n\n  Indicators.prototype.handleOptions = function () {\n    var UserIndicatorsOptions = this.scroll.options.indicators;\n    assert(Array.isArray(UserIndicatorsOptions), \"'indicators' must be an array.\");\n\n    for (var _i = 0, UserIndicatorsOptions_1 = UserIndicatorsOptions; _i < UserIndicatorsOptions_1.length; _i++) {\n      var indicatorOptions = UserIndicatorsOptions_1[_i];\n      assert(!!indicatorOptions.relationElement, \"'relationElement' must be a HTMLElement.\");\n      this.createIndicators(indicatorOptions);\n    }\n  };\n\n  Indicators.prototype.createIndicators = function (options) {\n    this.indicators.push(new Indicator(this.scroll, options));\n  };\n\n  Indicators.prototype.handleHooks = function () {\n    var _this = this;\n\n    var scrollHooks = this.scroll.hooks;\n    scrollHooks.on(scrollHooks.eventTypes.destroy, function () {\n      for (var _i = 0, _a = _this.indicators; _i < _a.length; _i++) {\n        var indicator = _a[_i];\n        indicator.destroy();\n      }\n\n      _this.indicators = [];\n    });\n  };\n\n  Indicators.pluginName = 'indicators';\n  return Indicators;\n}();\n\nBScroll.use(MouseWheel).use(ObserveDOM).use(PullDown).use(PullUp).use(ScrollBar).use(Slide).use(Wheel).use(Zoom).use(NestedScroll).use(InfinityScroll).use(Movable).use(ObserveImage).use(Indicators);\n\n\n//# sourceURL=webpack://fimls/./node_modules/better-scroll/dist/better-scroll.esm.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".cinema[data-v-67fb0868] {\\n  position: relative;\\n  width: 100%;\\n  overflow: hidden;\\n}\\n.cinema li[data-v-67fb0868] {\\n  position: relative;\\n  display: flex;\\n  justify-content: space-between;\\n  padding: 0.9375rem;\\n  background: #fff;\\n  margin-top: 0.125rem;\\n  font-size: 12px;\\n  color: #797d82;\\n}\\n.cinema li h1[data-v-67fb0868] {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  z-index: 33;\\n}\\n.cinema li .cinemaName[data-v-67fb0868] {\\n  font-size: 15px;\\n  color: #191a1b;\\n  margin-bottom: 0.3125rem;\\n}\\n.cinema li p[data-v-67fb0868] {\\n  width: 14rem;\\n  text-overflow: ellipsis;\\n  overflow: hidden;\\n  white-space: nowrap;\\n}\\n.cinema li span[data-v-67fb0868] {\\n  color: #ff5f16;\\n  font-size: 11px;\\n  text-overflow: ellipsis;\\n}\\n.cinema li span i[data-v-67fb0868] {\\n  font-size: 15px;\\n  font-style: normal;\\n}\", \"\"]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use%5B1%5D!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use%5B2%5D!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use%5B3%5D!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options");

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js??clonedRuleSet-22.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js??clonedRuleSet-22.use[0]!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!../../../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!../../../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!../../../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true& */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use[1]!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use[2]!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use[3]!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./src/components/cinemas/cinemaList.vue?vue&type=style&index=0&id=67fb0868&lang=scss&scoped=true&\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = (__webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ \"./node_modules/vue-style-loader/lib/addStylesClient.js\")[\"default\"])\nvar update = add(\"d16a3d58\", content, false, {\"sourceMap\":false,\"shadowMode\":false});\n// Hot Module Replacement\nif(false) {}\n\n//# sourceURL=webpack://fimls/./src/components/cinemas/cinemaList.vue?./node_modules/vue-style-loader/index.js??clonedRuleSet-22.use%5B0%5D!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-22.use%5B1%5D!./node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-22.use%5B2%5D!./node_modules/sass-loader/dist/cjs.js??clonedRuleSet-22.use%5B3%5D!./node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options");

/***/ })

}]);